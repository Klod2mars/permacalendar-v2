import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:share_plus/share_plus.dart';
import 'package:intl/intl.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'dart:convert';

import '../../core/data/hive/garden_boxes.dart';
import '../../core/models/activity.dart';
import '../../core/models/garden.dart';
import '../../core/models/garden_bed.dart';
import '../../garden/providers/garden_provider.dart';

class CreateTaskDialog extends ConsumerStatefulWidget {
  final DateTime? initialDate;

  const CreateTaskDialog({super.key, this.initialDate});

  @override
  ConsumerState<CreateTaskDialog> createState() => _CreateTaskDialogState();
}

class _CreateTaskDialogState extends ConsumerState<CreateTaskDialog> {
  final _formKey = GlobalKey<FormState>();

  // Fields
  String _title = '';
  String _description = '';
  String _taskKind = 'generic';
  String? _selectedGardenId; // Null means "All Gardens"
  String? _selectedGardenBedId;
  
  bool _urgent = false;
  String _priority = 'Medium'; // Low, Medium, High
  String _assignee = '';
  
  late DateTime _startDate;
  TimeOfDay? _startTime;
  int _durationMinutes = 60;
  
  // Recurrence
  Map<String, dynamic>? _recurrenceMap;
  
  // Available Task Kinds
  final Map<String, String> _taskKinds = {
    'generic': 'G√©n√©rique',
    'repair': 'R√©paration üõ†Ô∏è',
    'buy': 'Achat üõí',
    'clean': 'Nettoyage üßπ',
    'watering': 'Arrosage üíß',
    'seeding': 'Semis üå±',
    'pruning': 'Taille ‚úÇÔ∏è',
    'weeding': 'D√©sherbage üåø',
    'amendment': 'Amendement ü™µ',
    'treatment': 'Traitement üß™',
    'harvest': 'R√©colte üß∫',
    'winter_protection': 'Hivernage ‚ùÑÔ∏è',
  };

  final List<String> _priorities = ['Low', 'Medium', 'High'];

  @override
  void initState() {
    super.initState();
    _startDate = widget.initialDate ?? DateTime.now();
    
    // Auto-select garden if provider has one
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final gardenState = ref.read(gardenProvider);
      // We don't have direct access to 'selectedGarden' in the basic state usually, 
      // but let's assume we want to start with 'All' unless logic dictates otherwise.
      // If the user requirement said "Read via ref.read(gardenProvider)", we do so.
      // However, usually gardenProvider State is AsyncValue<List<Garden>> or similar.
      // We'll leave it as null (All) for now as a safe default, or pick first if only one.
      if (gardenState.gardens.length == 1) {
        setState(() {
          _selectedGardenId = gardenState.gardens.first.id;
        });
      }
    });
  }

  Future<void> _shareTask() async {
    final sb = StringBuffer();
    sb.writeln('T√¢che: $_title');
    
    // Resolve Garden Name
    String gardenName = 'Tous les jardins';
    if (_selectedGardenId != null) {
      final g = GardenBoxes.getGarden(_selectedGardenId!);
      if (g != null) gardenName = g.name;
    }
    sb.writeln('Jardin: $gardenName');
    
    // Resolve Bed Name
    String bedName = 'Aucune';
    if (_selectedGardenBedId != null) {
      final b = GardenBoxes.getGardenBedById(_selectedGardenBedId!);
      if (b != null) bedName = b.name;
    }
    sb.writeln('Parcelle: $bedName');
    
    sb.writeln('Description: ${_description.isEmpty ? "-" : _description}');
    
    final dateStr = DateFormat('yyyy-MM-dd').format(_startDate);
    final timeStr = _startTime != null ? ' ${_startTime!.format(context)}' : '';
    sb.writeln('D√©but: $dateStr$timeStr');
    
    sb.writeln('Dur√©e: $_durationMinutes minutes');
    sb.writeln('Type: ${_taskKinds[_taskKind] ?? _taskKind}');
    sb.writeln('Urgent: ${_urgent ? "Oui" : "Non"}');
    sb.writeln('Priorit√©: $_priority');
    sb.writeln('Assign√© √†: ${_assignee.isEmpty ? "-" : _assignee}');

    await Share.share(sb.toString());
  }
  
  Future<void> _saveTemplate() async {
    if (_title.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Titre requis pour le template')));
      return;
    }
    final prefs = await SharedPreferences.getInstance();
    final templateData = {
      'title': _title,
      'description': _description,
      'taskKind': _taskKind,
      'duration': _durationMinutes,
      'priority': _priority,
      'recurrence': _recurrenceMap,
    };
    await prefs.setString('task_template', jsonEncode(templateData));
    if (mounted) ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Template sauvegard√©')));
  }

  Future<void> _loadTemplate() async {
    final prefs = await SharedPreferences.getInstance();
    final String? raw = prefs.getString('task_template');
    if (raw != null) {
      final data = jsonDecode(raw);
      setState(() {
        _title = data['title'] ?? _title;
        _description = data['description'] ?? _description;
        _taskKind = data['taskKind'] ?? _taskKind;
        _durationMinutes = data['duration'] ?? _durationMinutes;
        _priority = data['priority'] ?? _priority;
        // Recurrence loading might be complex due to map structure, careful here.
        if (data['recurrence'] != null) {
             _recurrenceMap = Map<String, dynamic>.from(data['recurrence']);
        }
      });
      if (mounted) ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Template charg√©')));
    }
  }

  void _submit() {
    if (_formKey.currentState!.validate()) {
      _formKey.currentState!.save();
      
      try {
        DateTime finalDate = _startDate;
        if (_startTime != null) {
          finalDate = DateTime(
            _startDate.year, 
            _startDate.month, 
            _startDate.day, 
            _startTime!.hour, 
            _startTime!.minute
          );
        }

        final newTask = Activity.customTask(
          title: _title,
          description: _description,
          taskKind: _taskKind,
          zoneGardenBedId: _selectedGardenBedId,
          urgent: _urgent,
          recurrence: _recurrenceMap,
          nextRunDate: finalDate, // Using start date as next run date
          metadata: {
            'isCustomTask': true,
            'durationMinutes': _durationMinutes,
            'priority': _priority,
            'assignee': _assignee,
            'gardenId': _selectedGardenId, // Store garden scope explicitly
          },
        );

        GardenBoxes.activities.put(newTask.id, newTask);
        Navigator.pop(context, true);
      
      } catch (e) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Erreur cr√©ation t√¢che: $e'), backgroundColor: Colors.red),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Nouvelle T√¢che'),
        actions: [
           IconButton(
            icon: const Icon(Icons.share),
            tooltip: 'Partager (brouillon)',
            onPressed: () {
               _formKey.currentState?.save();
               _shareTask();
            },
          ),
          PopupMenuButton<String>(
            onSelected: (v) {
              if (v == 'save') _saveTemplate();
              if (v == 'load') _loadTemplate();
            },
            itemBuilder: (ctx) => [
              const PopupMenuItem(value: 'save', child: Text('Sauvegarder comme template')),
              const PopupMenuItem(value: 'load', child: Text('Charger le dernier template')),
            ],
          )
        ],
      ),
      bottomNavigationBar: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Row(
            children: [
              Expanded(
                child: OutlinedButton(
                  onPressed: () => Navigator.pop(context),
                  child: const Text('Annuler'),
                ),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: FilledButton(
                  onPressed: _submit,
                  child: const Text('Cr√©er'),
                ),
              ),
            ],
          ),
        ),
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16),
        child: Form(
          key: _formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              // Title
              TextFormField(
                decoration: const InputDecoration(
                  labelText: 'Titre *', 
                  border: OutlineInputBorder(),
                  prefixIcon: Icon(Icons.title),
                ),
                initialValue: _title,
                validator: (v) => v == null || v.isEmpty ? 'Requis' : null,
                onSaved: (v) => _title = v!,
                onChanged: (v) => _title = v, // update for share
              ),
              const SizedBox(height: 16),
              
              // Garden & Bed Selectors
              _GardenSelector(
                selectedGardenId: _selectedGardenId,
                onChanged: (id) {
                  setState(() {
                    _selectedGardenId = id;
                    _selectedGardenBedId = null; // Reset bed on garden change
                  });
                },
              ),
              const SizedBox(height: 12),
              
              _BedSelector(
                gardenId: _selectedGardenId,
                selectedBedId: _selectedGardenBedId,
                onChanged: (v) => setState(() => _selectedGardenBedId = v),
              ),
               const SizedBox(height: 16),

              // Description
              TextFormField(
                decoration: const InputDecoration(
                  labelText: 'Description',
                  border: OutlineInputBorder(),
                  alignLabelWithHint: true,
                ),
                maxLines: 3,
                initialValue: _description,
                onSaved: (v) => _description = v ?? '',
                 onChanged: (v) => _description = v,
              ),
              const SizedBox(height: 16),
              
              // Date & Time
              Row(
                children: [
                  Expanded(
                    child: InkWell(
                      onTap: () async {
                        final d = await showDatePicker(
                          context: context,
                          firstDate: DateTime(2020),
                          lastDate: DateTime(2030),
                          initialDate: _startDate,
                        );
                        if (d != null) setState(() => _startDate = d);
                      },
                      child: InputDecorator(
                        decoration: const InputDecoration(
                          labelText: 'Date de d√©but',
                          prefixIcon: Icon(Icons.calendar_today),
                          border: OutlineInputBorder(),
                        ),
                        child: Text(DateFormat('dd/MM/yyyy').format(_startDate)),
                      ),
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: InkWell(
                      onTap: () async {
                        final t = await showTimePicker(
                          context: context,
                          initialTime: _startTime ?? TimeOfDay.now(),
                        );
                        if (t != null) setState(() => _startTime = t);
                      },
                      child: InputDecorator(
                        decoration: const InputDecoration(
                          labelText: 'Heure',
                          prefixIcon: Icon(Icons.access_time),
                          border: OutlineInputBorder(),
                        ),
                        child: Text(_startTime?.format(context) ?? '--:--'),
                      ),
                    ),
                  ),
                ],
              ),
               const SizedBox(height: 16),
               
              // Duration
              Text('Dur√©e estim√©e', style: Theme.of(context).textTheme.titleSmall),
              const SizedBox(height: 8),
              Wrap(
                spacing: 8,
                children: [15, 30, 60, 120, 240].map((m) {
                  final isSelected = _durationMinutes == m;
                  return ChoiceChip(
                    label: Text('${m}m'),
                    selected: isSelected,
                    onSelected: (s) {
                       if (s) setState(() => _durationMinutes = m);
                    },
                  );
                }).toList()
                ..add(ChoiceChip(
                  label: const Text('Autre'),
                   selected: ![15, 30, 60, 120, 240].contains(_durationMinutes),
                   onSelected: (s) async {
                     // Simple dialog for custom duration
                     // For brevity we just focus logic; in a real app showDialog
                   },
                )),
              ),
              const SizedBox(height: 16),

              // Task Kind
              DropdownButtonFormField<String>(
                value: _taskKinds.containsKey(_taskKind) ? _taskKind : 'generic',
                decoration: const InputDecoration(
                  labelText: 'Type de t√¢che',
                  border: OutlineInputBorder(),
                  prefixIcon: Icon(Icons.category),
                ),
                items: _taskKinds.entries.map((e) {
                  return DropdownMenuItem(value: e.key, child: Text(e.value));
                }).toList(),
                onChanged: (v) => setState(() => _taskKind = v!),
              ),
              const SizedBox(height: 16),
              
              // Recurrence
              _RecurrenceEditor(
                initialValue: _recurrenceMap,
                onChanged: (map) {
                  _recurrenceMap = map;
                },
              ),
              const SizedBox(height: 16),

              // Priority & Urgent
              Row(
                children: [
                   Expanded(
                     child: DropdownButtonFormField<String>(
                      value: _priority,
                      decoration: const InputDecoration(
                        labelText: 'Priorit√©',
                         border: OutlineInputBorder(),
                      ),
                      items: _priorities.map((p) => DropdownMenuItem(value: p, child: Text(p))).toList(),
                      onChanged: (v) => setState(() => _priority = v!),
                   )),
                   const SizedBox(width: 16),
                   Expanded(
                     child: CheckboxListTile(
                      title: const Text('Urgent', style: TextStyle(fontWeight: FontWeight.bold, color: Colors.orange)),
                      value: _urgent,
                      contentPadding: EdgeInsets.zero,
                      onChanged: (v) => setState(() => _urgent = v!),
                   )),
                ],
              ),
              const SizedBox(height: 16),
              
              // Assignee & Attachments
              TextFormField(
                decoration: const InputDecoration(
                  labelText: 'Assign√© √†',
                  border: OutlineInputBorder(),
                  prefixIcon: Icon(Icons.person),
                  suffixIcon: Icon(Icons.contacts, color: Colors.grey), // Placeholder
                ),
                initialValue: _assignee,
                onChanged: (v) => _assignee = v,
              ),
              const SizedBox(height: 16),
               
              OutlinedButton.icon(
                onPressed: null, // Disabled as per requirements (placeholder)
                icon: const Icon(Icons.camera_alt),
                label: const Text('Ajouter une photo (Bient√¥t disponible)'),
              ),
              
              const SizedBox(height: 50), // Spacing for FAB/BottomBar
            ],
          ),
        ),
      ),
    );
  }
}

// ---------------------------------------------------------------------------
// SUB-WIDGETS (Inline)
// ---------------------------------------------------------------------------

class _GardenSelector extends ConsumerWidget {
  final String? selectedGardenId;
  final ValueChanged<String?> onChanged;

  const _GardenSelector({
    required this.selectedGardenId,
    required this.onChanged,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final gardensState = ref.watch(gardenProvider);

    if (gardensState.gardens.isEmpty) {
      return const SizedBox.shrink();
    }
    
    // Add "All Gardens" option (represented by null)
    final List<Garden?> options = [null, ...gardensState.gardens];

    return SingleChildScrollView(
      scrollDirection: Axis.horizontal,
      physics: const BouncingScrollPhysics(),
      child: Row(
        children: options.map((garden) {
          final isSelected = selectedGardenId == garden?.id;
          final label = garden?.name ?? 'Tous les jardins';
          
          return Padding(
            padding: const EdgeInsets.only(right: 8.0),
            child: FilterChip(
              label: Text(label),
              selected: isSelected,
              onSelected: (_) => onChanged(garden?.id),
              // Visual style from GardenMultiSelector
              backgroundColor: Colors.black54,
              selectedColor: Colors.greenAccent.withOpacity(0.2),
              checkmarkColor: Colors.greenAccent,
              labelStyle: TextStyle(
                color: isSelected ? Colors.greenAccent : Colors.white70,
                fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
              ),
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(20),
                side: BorderSide(
                  color: isSelected ? Colors.greenAccent : Colors.white24,
                ),
              ),
            ),
          );
        }).toList(),
      ),
    );
  }
}

class _BedSelector extends ConsumerWidget {
  final String? gardenId;
  final String? selectedBedId;
  final ValueChanged<String?> onChanged;

  const _BedSelector({
    required this.gardenId,
    required this.selectedBedId,
    required this.onChanged,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // Logic:
    // If gardenId != null -> getGardenBeds(gardenId)
    // If gardenId == null -> getAllGardens -> map getGardenBeds -> flat list with prefix
    
    List<DropdownMenuItem<String>> items = [];
    
    if (gardenId != null) {
      final beds = GardenBoxes.getGardenBeds(gardenId!);
      if (beds.isEmpty) {
         return const InputDecorator(
             decoration: InputDecoration(
               labelText: 'Zone (Parcelle)',
               border: OutlineInputBorder(),
             ),
             child: Text('Aucune parcelle pour ce jardin', style: TextStyle(color: Colors.grey)),
         );
      }
      
      items = beds.map((bed) {
        return DropdownMenuItem(value: bed.id, child: Text(bed.name));
      }).toList();
    } else {
      // All gardens
      final allGardens = GardenBoxes.getAllGardens();
      for (final g in allGardens) {
        final beds = GardenBoxes.getGardenBeds(g.id);
        for (final b in beds) {
           items.add(DropdownMenuItem(
             value: b.id,
             child: Text('${g.name} ‚Äî ${b.name}'),
           ));
        }
      }
    }
    
    items.insert(0, const DropdownMenuItem(value: null, child: Text('Aucune zone sp√©cifique')));

    return DropdownButtonFormField<String>(
      value: selectedBedId,
      decoration: const InputDecoration(
        labelText: 'Zone (Parcelle)',
        border: OutlineInputBorder(),
        prefixIcon: Icon(Icons.grid_on),
      ),
      isExpanded: true,
      items: items,
      onChanged: onChanged,
    );
  }
}

class _RecurrenceEditor extends StatefulWidget {
  final Map<String, dynamic>? initialValue;
  final ValueChanged<Map<String, dynamic>?> onChanged;

  const _RecurrenceEditor({this.initialValue, required this.onChanged});

  @override
  State<_RecurrenceEditor> createState() => _RecurrenceEditorState();
}

class _RecurrenceEditorState extends State<_RecurrenceEditor> {
  String _type = 'none';
  int _intervalEvery = 7;
  List<int> _selectedDays = []; // 1=Mon, 7=Sun

  @override
  void initState() {
    super.initState();
    if (widget.initialValue != null) {
      _type = widget.initialValue?['type'] ?? 'none';
      _intervalEvery = widget.initialValue?['every'] ?? 7;
      if (widget.initialValue?['days'] != null) {
        _selectedDays = List<int>.from(widget.initialValue!['days']);
      }
    }
  }

  void _update() {
    if (_type == 'none') {
      widget.onChanged(null);
    } else {
      final map = <String, dynamic>{'type': _type};
      if (_type == 'interval') map['every'] = _intervalEvery;
      if (_type == 'weekly') map['days'] = _selectedDays;
      if (_type == 'monthlyByDay') {
        // usually needs day of month, implied from start date in logic? 
        // For now just marking type for logic to pick up.
        // Or we can store 'day': DateTime.now().day if needed, but let's keep simple.
      }
      widget.onChanged(map);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        DropdownButtonFormField<String>(
          value: _type,
          decoration: const InputDecoration(
            labelText: 'R√©currence',
             border: OutlineInputBorder(),
             prefixIcon: Icon(Icons.repeat),
          ),
          items: const [
            DropdownMenuItem(value: 'none', child: Text('Aucune')),
            DropdownMenuItem(value: 'interval', child: Text('Tous les X jours')),
            DropdownMenuItem(value: 'weekly', child: Text('Hebdomadaire (Jours)')),
            DropdownMenuItem(value: 'monthlyByDay', child: Text('Mensuel (M√™me jour)')),
          ],
          onChanged: (v) {
            setState(() => _type = v!);
            _update();
          },
        ),
        
        if (_type == 'interval')
          Padding(
            padding: const EdgeInsets.only(top: 12.0),
            child: Row(
              children: [
                const Text('R√©p√©ter tous les '),
                SizedBox(
                  width: 80,
                  child: TextFormField(
                    initialValue: _intervalEvery.toString(),
                    keyboardType: TextInputType.number,
                    decoration: const InputDecoration(suffixText: ' j'),
                    onChanged: (v) {
                       final val = int.tryParse(v);
                       if (val != null) {
                         _intervalEvery = val;
                         _update();
                       }
                    },
                  ),
                ),
              ],
            ),
          ),
          
        if (_type == 'weekly')
           Padding(
             padding: const EdgeInsets.only(top: 12.0),
             child: Wrap(
               spacing: 4,
               children: ['L', 'M', 'M', 'J', 'V', 'S', 'D'].asMap().entries.map((e) {
                  final dayIndex = e.key + 1; // 1-based
                  final isSelected = _selectedDays.contains(dayIndex);
                  return FilterChip(
                    label: Text(e.value),
                    selected: isSelected,
                    onSelected: (selected) {
                       setState(() {
                         if (selected) {
                           _selectedDays.add(dayIndex);
                           _selectedDays.sort();
                         } else {
                           _selectedDays.remove(dayIndex);
                         }
                       });
                       _update();
                    },
                  );
               }).toList(),
             ),
           ),
      ],
    );
  }
}
