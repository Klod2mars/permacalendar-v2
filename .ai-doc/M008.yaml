mission_id: "M008"
title: "M008 — Backup Hive (Windows) + Préparation lot 1 (.family scaffolds) — Cursor"
created_by: "perma-assistant"
created_at: !!timestamp "2025-11-09T00:00:00Z"
description: |
  Mission Cursor : sauvegarde locale des boxes Hive (Windows uniquement — le téléphone a été désinstallé),
  puis préparation non-destructive et commit de 3 providers sûrs en branches locales pour révision :
  - filteredEvolutionHistoryProvider
  - plantEvolutionHistoryProvider
  - latestEvolutionProvider

  Contraintes / conventions :
  - Aucune extraction Android (le téléphone est désinstallé). Pas d'accès adb.
  - Ne PAS pousser sur l'origine ; l'opérateur (tu) fera le push / revue PR après la mission.
  - Les providers en collision (ex. gardenBedProvider) sont SKIPPÉS automatiquement.
  - Le script `.scripts/apply_provider_patches.ps1` doit être présent (créé lors du M008 draft). La mission exécute la préparation réelle (scaffold + commit + branches) et lance les tests locaux (`-RunTests`) mais **ne pousse pas** les branches.
preconditions:
  - Exécuter depuis la racine du dépôt git local.
  - PowerShell (pwsh) disponible.
  - `flutter` et `dart` disponibles si `-RunTests` déclenche `build_runner` / `flutter test`.
  - `.scripts/apply_provider_patches.ps1` et `.ai-doc/M008.yaml` présents (créés précédemment).
variables:
  providers: "filteredEvolutionHistoryProvider,plantEvolutionHistoryProvider,latestEvolutionProvider"
  backup_dest_base: "${env:USERPROFILE}\\Documents\\permacalendar_hive_backup"
steps:
  - name: "1 — Vérification repo & commit des assets M008 si non commités"
    shell: "pwsh"
    run: |
      Write-Host "=== Step 1: vérification git et commit des assets M008 ==="
      if (-not (git rev-parse --is-inside-work-tree 2>$null)) {
        Write-Error "Pas dans un dépôt git. Abandon."
        exit 1
      }

      # Vérifier l'état ; autoriser uniquement les fichiers .ai-doc/ et .scripts/ non commités
      $status = git status --porcelain
      $dirty = $status -split "`n" | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne "" }
      $unsafe = @()
      foreach ($line in $dirty) {
        $path = $line -replace '^[ MADRCU?!]*\s*',''
        if ($path -notmatch '^(?:\.ai-doc/|\.ai-doc\\|\.scripts/|\.scripts\\)') {
          $unsafe += $path
        }
      }
      if ($unsafe.Count -gt 0) {
        Write-Error "Working tree dirty avec fichiers hors .ai-doc/ ou .scripts/:"
        $unsafe | ForEach-Object { Write-Host " - $_" }
        Write-Error "Nettoyez ou commitez ces fichiers avant de poursuivre."
        exit 2
      }

      # Commit des assets M008 si présents et non commités
      $toAdd = @(".ai-doc/M008.yaml", ".scripts/apply_provider_patches.ps1", ".ai-doc/applied_patches", ".ai-doc/applied_patches/README.md", ".ai-doc/applied_patches/index.yaml")
      $present = @()
      foreach ($p in $toAdd) { if (Test-Path $p) { $present += $p } }
      if ($present.Count -gt 0) {
        git add $present 2>$null
        if ((git diff --cached --name-only) -ne "") {
          git commit -m "M008: add apply_provider_patches script and applied_patches scaffolding (Cursor run)"
          Write-Host "Committed M008 assets."
        } else {
          Write-Host "M008 assets déjà staged/committés."
        }
      } else {
        Write-Host "Aucun asset M008 trouvé à committer."
      }
      Write-Host "Step 1 OK."

  - name: "2 — Sauvegarde Hive (Windows uniquement)"
    shell: "pwsh"
    run: |
      Write-Host "=== Step 2: backup Hive local (Windows) ==="
      $patterns = @('germination_events','plantings','gardens','plants','activities','garden_beds','plant_varieties','growth_cycles','plant_conditions','weather_conditions','recommendations','notification_alerts','plant_analyses','active_alerts','pest_observations','bio_control_recommendations')
      $ts = (Get-Date).ToString('yyyyMMdd_HHmmss')
      $backupDir = Join-Path "${env:USERPROFILE}\Documents" "permacalendar_hive_backup_$ts"
      New-Item -ItemType Directory -Path $backupDir -Force | Out-Null
      Write-Host "Backup directory: $backupDir"

      $roots = @()
      if ($env:APPDATA) { $roots += $env:APPDATA }
      if ($env:LOCALAPPDATA) { $roots += $env:LOCALAPPDATA }
      $roots += (Get-Location).Path  # in case dev used repo-local hive files

      $foundAny = $false
      foreach ($r in $roots | Select-Object -Unique) {
        if (-not (Test-Path $r)) { continue }
        Write-Host "Searching .hive files in $r ..."
        try {
          $matches = Get-ChildItem -Path $r -Recurse -Filter '*.hive' -ErrorAction SilentlyContinue
        } catch {
          $matches = @()
        }
        foreach ($m in $matches) {
          if ($patterns -contains $m.BaseName) {
            $foundAny = $true
            Write-Host "Copying $($m.FullName) to $backupDir"
            Copy-Item -Path $m.FullName -Destination $backupDir -Force
          }
        }
      }

      if (-not $foundAny) {
        Write-Warning "Aucun fichier .hive correspondant trouvé localement. Continuera sans backup local des boxes (ok si l'app était désinstallée)."
        # still create empty marker for traceability
        New-Item -Path (Join-Path $backupDir "NO_HIVE_FILES_FOUND.txt") -ItemType File -Force | Out-Null
      } else {
        $zipPath = "$backupDir.zip"
        Write-Host "Compression du backup -> $zipPath"
        Compress-Archive -Path (Join-Path $backupDir '*') -DestinationPath $zipPath -Force
        Write-Host "Backup complet : $zipPath"
      }

      # Output path for mission summary
      Set-Content -Path (Join-Path $backupDir "backup_meta.txt") -Value ("backup_base=$backupDir`nzip=" + (if (Test-Path $zipPath) { $zipPath } else { "" }))
      Write-Host "Step 2 OK."

  - name: "3 — Vérification backup"
    shell: "pwsh"
    run: |
      Write-Host "=== Step 3: vérification du backup ==="
      $zips = Get-ChildItem -Path "${env:USERPROFILE}\Documents" -Filter "permacalendar_hive_backup_*.zip" -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending
      if ($zips.Count -gt 0) {
        Write-Host "Backups trouvés (plus récent en tête) :"
        $zips | Select-Object Name,FullName,LastWriteTime | Format-Table -AutoSize
      } else {
        Write-Warning "Aucun archive .zip trouvé dans Documents. (Ceci est acceptable si l'app a été désinstallée et aucune .hive locale n'existe.)"
      }
      Write-Host "Step 3 OK."

  - name: "4 — Préparer les providers (scaffold .family) — exécution réelle (sans push)"
    shell: "pwsh"
    run: |
      Write-Host "=== Step 4: exécution apply_provider_patches.ps1 pour providers sûrs ==="
      $script = ".scripts\apply_provider_patches.ps1"
      if (-not (Test-Path $script)) {
        Write-Error "$script introuvable. Assure-toi qu'il existe sous .scripts/ (créé lors du M008 draft)."
        exit 1
      }

      $provArg = "filteredEvolutionHistoryProvider,plantEvolutionHistoryProvider,latestEvolutionProvider"
      Write-Host "Providers ciblés: $provArg"
      Write-Host "Note: gardenBedProvider sera automatiquement ignoré (collision)."

      # Exécuter le script sans -PushBranch car tu feras le push toi-même après revue
      Write-Host "Lancement du script (préparation réelle + tests locaux) :"
      Write-Host "powershell -ExecutionPolicy Bypass -File $script -Providers $provArg -RunTests"
      powershell -ExecutionPolicy Bypass -File $script -Providers $provArg -RunTests
      if ($LASTEXITCODE -ne 0) {
        Write-Warning "Le script apply_provider_patches.ps1 a retourné un code non nul. Vérifier les logs ci-dessus."
      } else {
        Write-Host "apply_provider_patches.ps1 terminé (scaffolds committés sur branches locales)."
      }
      Write-Host "Step 4 OK."

  - name: "5 — Collecte artefacts & résumé final (prêt pour push manuel)"
    shell: "pwsh"
    run: |
      Write-Host "=== Step 5: collecte des artefacts ==="
      Write-Host "Branches locales créées (pattern apply-provider/*-m008):"
      git for-each-ref --format='%(refname:short)' refs/heads | Where-Object { $_ -like 'apply-provider/*-m008' } | ForEach-Object { Write-Host " - $_" }

      Write-Host ""
      if (Test-Path ".ai-doc/applied_patches") {
        Write-Host "Fichiers sous .ai-doc/applied_patches/:"
        Get-ChildItem -Path ".ai-doc/applied_patches" -Force | Select-Object Name,Length,LastWriteTime | Format-Table -AutoSize
      } else {
        Write-Host " - .ai-doc/applied_patches/ absent."
      }

      Write-Host ""
      Write-Host "Derniers commits (10):"
      git --no-pager log -n 10 --pretty=format:"%h %ad %s" --date=iso

      Write-Host ""
      Write-Host "Local backups in Documents (latest):"
      Get-ChildItem -Path "${env:USERPROFILE}\Documents" -Filter "permacalendar_hive_backup_*" -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object Name,FullName,LastWriteTime | Format-Table -AutoSize

      Write-Host ""
      Write-Host "IMPORTANT: Aucune branche n'a été poussée par cette mission. Tu peux maintenant :"
      Write-Host "  1) inspecter les branches apply-provider/*-m008, éditer les fichiers scaffoldés (remplacer TODO par conversion .family),"
      Write-Host "  2) exécuter build_runner + tests localement pour chaque branche (ou utiliser la branche locale créée),"
      Write-Host "  3) faire un 'safe push' / créer PRs vers origin/main quand tu es prêt."
      Write-Host "Mission M008 complète."

outputs:
  - description: "Liste des branches locales apply-provider/*-m008 créées"
  - description: "Fichiers .ai-doc/applied_patches/*.patch.md (status: prepared) créés"
  - description: "Chemin(s) des archives backup Hive (si trouvées) dans Documents"
  - description: "Logs d'exécution (build_runner / flutter test) imprimés dans la sortie de la mission"
notes: |
  - Cette mission n'effectue **pas** de push remote. Tu es responsable du push / PR après revue.
  - Les providers en collision (gardenBedProvider) sont SKIPPÉS et listés dans les logs pour revue manuelle.
  - Si des erreurs apparaissent pendant `build_runner` ou `flutter test`, consulte la sortie complète ; corrige localement sur les branches créées puis commit/push.
  - Si tu veux que Cursor pousse automatiquement les branches (backup tag + push), je peux générer une variante qui inclut -PushBranch — dis-le et j'adapte le YAML.
