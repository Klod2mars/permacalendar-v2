mission_id: "M008_cursor_auto_1-4_always"
title: "M008 (Cursor) — Automatisation steps 1→4 (détection, regen rapports, vérif définitions, preparation/scaffold)"
created_by: "perma-assistant"
created_at: !!timestamp "2025-11-09T00:00:00Z"
# Demande explicite: exécuter tout le temps / always
always: true

description: |
  Mission Cursor : automatise et enchaîne les étapes 1→4 :
    1) détecter la présence des providers ciblés (ou extraire top candidates depuis provider_family_report.csv),
    2) (si nécessaire) régénérer les rapports detect_provider_calls / analyze_provider_families,
    3) vérifier les définitions exactes dans le code,
    4) lancer .scripts/apply_provider_patches.ps1 pour les providers valides (préparation réelle, tests locaux, sans push).
  Le flux est résilient : il essaie de poursuivre même si certaines sous-étapes échouent, et produit un rapport structuré final.
preconditions:
  - Exécuter depuis la racine du dépôt git local.
  - PowerShell (pwsh) disponible dans l'environnement de Cursor.
  - flutter/dart disponibles si -RunTests déclenche build_runner/flutter test.
variables:
  # Si providers est vide, on prendra les top N du provider_family_report.csv (ou .ai-doc/patches fallback)
  providers: ""
  top_n: 5

steps:
  - name: "0. Préparation: variables & sanity checks"
    shell: "pwsh"
    run: |
      $ErrorActionPreference = "Continue"
      Write-Host "=== M008_cursor_auto: initialisation ==="
      if (-not (git rev-parse --is-inside-work-tree 2>$null)) {
        Write-Error "Pas dans un dépôt git. Abandon."
        exit 1
      }
      if (-not (Test-Path ".scripts/apply_provider_patches.ps1")) {
        Write-Warning ".scripts/apply_provider_patches.ps1 introuvable — la mission continuera mais échouera à l'étape d'application."
      } else {
        Write-Host "Found apply_provider_patches script."
      }
      if (-not (Test-Path ".ai-doc/patches")) {
        Write-Warning ".ai-doc/patches absent — le script de patchs peut toujours utiliser provider_family_report.csv."
      }
      if (-not (Test-Path "provider_family_report.csv")) {
        Write-Host "provider_family_report.csv absent (c'est acceptable); on tentera de régénérer si nécessaire."
      }
      # Ensure applied_patches dir exists
      if (!(Test-Path ".ai-doc/applied_patches")) { New-Item -ItemType Directory -Path ".ai-doc/applied_patches" | Out-Null }
      # Normalize input providers variable (Cursor may pass blank)
      $env:TARGET_PROVIDERS = "${{ variables.providers }}"
      $env:TOP_N = "${{ variables.top_n }}"
      Write-Host "TARGET_PROVIDERS='$env:TARGET_PROVIDERS' TOP_N=$env:TOP_N"
      Write-Host "Step 0 OK."

  - name: "1. Détecter les providers cibles (entrée ou top N du rapport)"
    shell: "pwsh"
    run: |
      $ErrorActionPreference = "Continue"
      $provided = $env:TARGET_PROVIDERS.Trim()
      $providers = @()
      if ($provided -ne "") {
        # accept comma-separated or array-like
        if ($provided -match ',') {
          $providers = $provided -split ',' | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne "" }
        } else {
          $providers = $provided -split '\s+' | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne "" }
        }
        Write-Host "Providers from variables: $($providers -join ', ')"
      } else {
        # Try to read top N from provider_family_report.csv
        if (Test-Path "provider_family_report.csv") {
          try {
            $rows = Import-Csv "provider_family_report.csv" | Where-Object { $_.is_family -eq "False" -and $_.defined_in -ne "" } | Sort-Object -Property usages -Descending
            if ($rows.Count -gt 0) {
              $n = [int]$env:TOP_N
              $candidates = $rows | Select-Object -First $n
              $providers = $candidates | ForEach-Object { $_.provider }
              Write-Host "Providers from provider_family_report.csv (top $n): $($providers -join ', ')"
            } else {
              Write-Host "provider_family_report.csv present but without candidates."
            }
          } catch {
            Write-Warning "Erreur lecture provider_family_report.csv: $_"
          }
        }
        # Fallback: list files under .ai-doc/patches
        if ($providers.Count -eq 0 -and Test-Path ".ai-doc/patches") {
          $providers = Get-ChildItem -Path ".ai-doc/patches" -Filter "*.md" -ErrorAction SilentlyContinue | Select-Object -First $env:TOP_N -ExpandProperty BaseName
          if ($providers) { Write-Host "Providers fallback from .ai-doc/patches: $($providers -join ', ')" }
        }
      }
      # final fallback: none provided
      if (-not $providers -or $providers.Count -eq 0) {
        Write-Warning "Aucun provider ciblé détecté automatiquement. La mission s'arrêtera proprement."
      }
      # export for next steps
      $providers | ConvertTo-Json -Compress | Set-Content -Path ".ai-doc/applied_patches/selected_providers.json" -Encoding UTF8
      Write-Host "Selected providers saved to .ai-doc/applied_patches/selected_providers.json"

  - name: "2. Vérifier localement l'existence des définitions (search repo)"
    shell: "pwsh"
    run: |
      $ErrorActionPreference = "Continue"
      $selFile = ".ai-doc/applied_patches/selected_providers.json"
      if (-not (Test-Path $selFile)) {
        Write-Warning "Sélection providers manquante: aborting step 2."
        exit 0
      }
      $providers = (Get-Content $selFile -Raw | ConvertFrom-Json)
      if (-not $providers) {
        Write-Warning "Aucun provider à traiter."
        exit 0
      }
      $found = @{}
      foreach ($prov in $providers) {
        $found[$prov] = @{ definitions = @(); notes = "" }
        # Search for exact final <prov> = pattern
        try {
          $defs = Select-String -Path .\**\*.dart -Pattern ("final\s+" + [regex]::Escape($prov) + "\s*=") -List -ErrorAction SilentlyContinue
        } catch { $defs = @() }
        if ($defs) {
          foreach ($d in $defs) {
            $found[$prov].definitions += "$($d.Path):$($d.LineNumber)"
          }
        } else {
          # Try searching for the radical (without Provider) and @riverpod annotations
          $radical = $prov -replace 'Provider$',''
          try {
            $alt = Select-String -Path .\**\*.dart -Pattern $radical -List -ErrorAction SilentlyContinue
          } catch { $alt = @() }
          if ($alt) {
            foreach ($a in $alt) {
              $found[$prov].definitions += "$($a.Path):$($a.LineNumber)"
            }
            $found[$prov].notes = "No exact 'final $prov =' found; matched radical occurrences."
          }
        }
      }
      # write a human readable report
      $report = ".ai-doc/applied_patches/definition_report.txt"
      "Definition report generated on $(Get-Date -Format o)" | Out-File $report -Encoding UTF8
      foreach ($k in $found.Keys) {
        Add-Content -Path $report -Value "" -Encoding UTF8
        Add-Content -Path $report -Value "Provider: $k" -Encoding UTF8
        if ($found[$k].definitions.Count -gt 0) {
          Add-Content -Path $report -Value "  Definitions:" -Encoding UTF8
          $found[$k].definitions | ForEach-Object { Add-Content -Path $report -Value "    - $_" -Encoding UTF8 }
        } else {
          Add-Content -Path $report -Value "  Definitions: NONE FOUND" -Encoding UTF8
        }
        if ($found[$k].notes) { Add-Content -Path $report -Value "  Notes: $($found[$k].notes)" -Encoding UTF8 }
      }
      Write-Host "Definition report written to $report"
      # Save a JSON of found info for decision making
      $found | ConvertTo-Json -Compress | Set-Content -Path ".ai-doc/applied_patches/definition_report.json" -Encoding UTF8

  - name: "3. Si aucune définition trouvée, régénérer rapports detect & analyze"
    shell: "pwsh"
    run: |
      $ErrorActionPreference = "Continue"
      $defJson = ".ai-doc/applied_patches/definition_report.json"
      if (-not (Test-Path $defJson)) {
        Write-Warning "definition_report.json absent — skipping regen step."
        exit 0
      }
      $info = (Get-Content $defJson -Raw | ConvertFrom-Json)
      $noneCount = 0
      foreach ($k in $info.PSObject.Properties.Name) {
        if ($info.$k.definitions.Count -eq 0) { $noneCount += 1 }
      }
      if ($noneCount -eq 0) {
        Write-Host "Des définitions ont été trouvées pour tous les providers sélectionnés; pas de régénération nécessaire."
        exit 0
      }
      Write-Host "$noneCount providers sans définition exacte ; tenter de régénérer detect_provider_calls/analyze_provider_families si disponibles."

      if (Test-Path ".scripts/detect_provider_calls.ps1") {
        try {
          Write-Host "Running .scripts/detect_provider_calls.ps1"
          powershell -ExecutionPolicy Bypass -File .scripts/detect_provider_calls.ps1
          Write-Host "detect_provider_calls completed."
        } catch { Write-Warning "detect_provider_calls.ps1 failed: $_" }
      } else {
        Write-Warning ".scripts/detect_provider_calls.ps1 not found."
      }

      if (Test-Path ".scripts/analyze_provider_families.ps1") {
        try {
          Write-Host "Running .scripts/analyze_provider_families.ps1"
          powershell -ExecutionPolicy Bypass -File .scripts/analyze_provider_families.ps1
          Write-Host "analyze_provider_families completed."
        } catch { Write-Warning "analyze_provider_families.ps1 failed: $_" }
      } else {
        Write-Warning ".scripts/analyze_provider_families.ps1 not found."
      }
      Write-Host "Step 3 finished: reports regenerated if scripts were present."

  - name: "4. Re-vérifier définitions après regen (idempotent)"
    shell: "pwsh"
    run: |
      $ErrorActionPreference = "Continue"
      # Re-run step 2 logic to refresh definition_report
      Write-Host "Re-running definition detection..."
      $selFile = ".ai-doc/applied_patches/selected_providers.json"
      if (-not (Test-Path $selFile)) { Write-Warning "selected_providers.json missing; aborting step 4."; exit 0 }
      $providers = (Get-Content $selFile -Raw | ConvertFrom-Json)
      $found = @{}
      foreach ($prov in $providers) {
        $found[$prov] = @{ definitions = @(); notes = "" }
        $defs = @()
        try { $defs = Select-String -Path .\**\*.dart -Pattern ("final\s+" + [regex]::Escape($prov) + "\s*=") -List -ErrorAction SilentlyContinue } catch { $defs = @() }
        if ($defs) {
          foreach ($d in $defs) { $found[$prov].definitions += "$($d.Path):$($d.LineNumber)" }
        } else {
          $radical = $prov -replace 'Provider$',''
          try { $alt = Select-String -Path .\**\*.dart -Pattern $radical -List -ErrorAction SilentlyContinue } catch { $alt = @() }
          if ($alt) {
            foreach ($a in $alt) { $found[$prov].definitions += "$($a.Path):$($a.LineNumber)" }
            $found[$prov].notes = "No exact 'final $prov =' found; matched radical occurrences."
          }
        }
      }
      $report = ".ai-doc/applied_patches/definition_report_after_regen.txt"
      "Definition report (after regen) on $(Get-Date -Format o)" | Out-File $report -Encoding UTF8
      foreach ($k in $found.Keys) {
        Add-Content -Path $report -Value "" -Encoding UTF8
        Add-Content -Path $report -Value "Provider: $k" -Encoding UTF8
        if ($found[$k].definitions.Count -gt 0) {
          Add-Content -Path $report -Value "  Definitions:" -Encoding UTF8
          $found[$k].definitions | ForEach-Object { Add-Content -Path $report -Value "    - $_" -Encoding UTF8 }
        } else {
          Add-Content -Path $report -Value "  Definitions: NONE FOUND" -Encoding UTF8
        }
        if ($found[$k].notes) { Add-Content -Path $report -Value "  Notes: $($found[$k].notes)" -Encoding UTF8 }
      }
      Write-Host "Wrote re-check report to $report"
      $found | ConvertTo-Json -Compress | Set-Content -Path ".ai-doc/applied_patches/definition_report_after_regen.json" -Encoding UTF8

  - name: "5. Préparer la liste finale des providers à appliquer et lancer apply_provider_patches.ps1 -RunTests (sans push)"
    shell: "pwsh"
    run: |
      $ErrorActionPreference = "Continue"
      $defJson = ".ai-doc/applied_patches/definition_report_after_regen.json"
      if (-not (Test-Path $defJson)) {
        $defJson = ".ai-doc/applied_patches/definition_report.json"
      }
      if (-not (Test-Path $defJson)) {
        Write-Warning "Aucun rapport de définition trouvé; aborting step 5."
        exit 0
      }
      $info = (Get-Content $defJson -Raw | ConvertFrom-Json)
      $toApply = @()
      foreach ($k in $info.PSObject.Properties.Name) {
        if ($info.$k.definitions.Count -gt 0) { $toApply += $k } else { Write-Host "Skipping $k (no definitions)"; }
      }
      if ($toApply.Count -eq 0) {
        Write-Warning "Aucun provider valide à appliquer. Rien à faire."
        exit 0
      }
      $provArg = $toApply -join ","
      Write-Host "Final providers to apply: $provArg"

      $script = ".scripts\apply_provider_patches.ps1"
      if (-not (Test-Path $script)) { Write-Error "$script not found; cannot apply patches."; exit 1 }

      # Run the apply script with -RunTests but without -PushBranch to keep changes local
      try {
        Write-Host "Running apply_provider_patches.ps1 -Providers $provArg -RunTests"
        powershell -ExecutionPolicy Bypass -File $script -Providers $provArg -RunTests
        Write-Host "apply_provider_patches.ps1 finished (see logs above)."
      } catch {
        Write-Warning "apply_provider_patches invocation failed: $_"
      }

  - name: "6. Collecte finale: branches / applied_patches / backups / logs"
    shell: "pwsh"
    run: |
      $ErrorActionPreference = "Continue"
      Write-Host "Collecte finale des artefacts..."
      Write-Host "Branches locales apply-provider/*-m008 :"
      git for-each-ref --format='%(refname:short)' refs/heads | Where-Object { $_ -like 'apply-provider/*-m008' } | ForEach-Object { Write-Host " - $_" }

      Write-Host ""
      if (Test-Path ".ai-doc/applied_patches") {
        Write-Host ".ai-doc/applied_patches contents:"
        Get-ChildItem -Path ".ai-doc/applied_patches" -Force | Select-Object Name,Length,LastWriteTime | Format-Table -AutoSize
      } else {
        Write-Host ".ai-doc/applied_patches absent."
      }

      Write-Host ""
      Write-Host "Local backup archives (Documents):"
      Get-ChildItem -Path "${env:USERPROFILE}\Documents" -Filter "permacalendar_hive_backup_*" -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object Name,FullName,LastWriteTime | Format-Table -AutoSize

      Write-Host ""
      Write-Host "Derniers commits (10) :"
      git --no-pager log -n 10 --pretty=format:"%h %ad %s" --date=iso

      Write-Host ""
      Write-Host "Definition reports (if any):"
      Get-ChildItem -Path ".ai-doc/applied_patches" -Filter "*definition_report*.txt" -ErrorAction SilentlyContinue | ForEach-Object { Write-Host " - $($_.FullName)" }

outputs:
  - description: "selected_providers.json (providers candidates)"
  - description: "definition_report.txt / definition_report_after_regen.txt"
  - description: ".ai-doc/applied_patches/*.patch.md (prepared/skipped)"
  - description: "Branches locales apply-provider/*-m008 (si créées)"
  - description: "Local Hive backup archives (if any) and backup marker"
notes: |
  - Cette mission est idempotente : elle peut être relancée autant de fois que nécessaire.
  - Elle tente de régénérer les rapports si les définitions manquent, puis retente la détection et l'application.
  - Elle n'inclut pas de push automatique des branches (tu gardes le contrôle pour revue / push).
  - Si tu veux que Cursor pousse automatiquement après préparation, je peux fournir une variante avec -PushBranch activé.
