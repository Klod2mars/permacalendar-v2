--- FILE: pubspec.yaml ---
0001: name: permacalendar
0002: description: "Application professionnelle de gestion de jardinage en permaculture"
0003: publish_to: 'none'
0004: version: 2.0.0+1
0005: 
0006: environment:
0007:   sdk: '>=3.1.0 <4.0.0'
0008: 
0009: dependencies:
0010:   auto_size_text: ^3.0.0
0011:   flutter:
0012:     sdk: flutter
0013:   
0014:   # State Management
0015:   flutter_riverpod: ^3.0.3
0016:   riverpod: ^3.0.3
0017:   riverpod_annotation: ^3.0.0
0018:   
0019:   # Local Database
0020:   hive: ^2.2.3
0021:   hive_flutter: ^1.1.0
0022:   
0023:   # Navigation
0024:   go_router: ^16.2.4
0025:   
0026:   # Network
0027:   dio: ^5.4.0
0028:   connectivity_plus: ^7.0.0
0029:   
0030:   # UI Components
0031:   cupertino_icons: ^1.0.2
0032:   flutter_svg: ^2.0.9
0033:   cached_network_image: ^3.3.0
0034:   
0035:   # Utils
0036:   intl: ^0.20.2
0037:   uuid: ^4.2.1
0038:   path_provider: ^2.1.1
0039:   
0040:   # Weather & Location
0041:   geolocator: ^14.0.2
0042:   weather: ^3.1.1
0043:   
0044:   # Export & Analytics
0045:   csv: ^6.0.0
0046:   pdf: ^3.10.7
0047:   share_plus: ^12.0.0
0048:   
0049:   # Environment
0050:   flutter_dotenv: ^6.0.0
0051:   
0052:   # Notifications
0053:   flutter_local_notifications: ^19.4.2
0054:   flutter_local_notifications_platform_interface: ^9.1.0
0055:   flutter_local_notifications_linux: ^6.0.0
0056:   
0057:   # Charts & Visualization
0058:   fl_chart: ^1.1.1
0059:   
0060:   # Code Generation
0061:   freezed_annotation: ^2.4.1
0062:   json_annotation: ^4.9.0
0063: 
0064: dev_dependencies:
0065:   flutter_test:
0066:     sdk: flutter
0067:   
0068:   # Code Generation
0069:   hive_generator: ^2.0.1
0070:   build_runner: ^2.4.13
0071:   json_serializable: ^6.7.1
0072:   freezed: ^2.5.2
0073:   riverpod_generator: ^3.0.0-dev.11
0074:   
0075:   # Linting
0076:   flutter_lints: ^3.0.0
0077:   
0078:   # Testing
0079:   mockito: ^5.4.4
0080:   integration_test:
0081:     sdk: flutter
0082:   path: ^1.9.1
0083: 
0084: flutter:
0085:   uses-material-design: true
0086:   
0087:   assets:
0088:     - assets/data/
0089:     - assets/images/
0090:     - assets/images/plants/
0091:     - assets/images/icons/
0092:     - assets/images/backgrounds/
0093:     - assets/images/social/
0094:     - .env
0095:   
0096:   fonts:
0097:     - family: Roboto
0098:       fonts:
0099:         - asset: assets/fonts/Roboto-Regular.ttf
0100:         - asset: assets/fonts/Roboto-Bold.ttf
0101:           weight: 700
--- FILE: lib/shared/presentation/screens/home_screen.dart ---
0001: ﻿// lib/shared/presentation/screens/home_screen.dart
0002: import 'package:flutter/material.dart';
0003: import 'package:flutter_riverpod/flutter_riverpod.dart';
0004: import 'package:go_router/go_router.dart';
0005: import 'package:flutter/services.dart';
0006: 
0007: import '../../../app_router.dart';
0008: import '../../../core/services/open_meteo_service.dart';
0009: import 'package:permacalendar/features/garden/providers/garden_provider.dart';
0010: import '../../../core/models/garden_state.dart';
0011: import '../../../features/garden/widgets/garden_card_with_real_area.dart';
0012: import '../../../shared/widgets/custom_app_bar.dart';
0013: import '../../../shared/widgets/custom_card.dart';
0014: import '../../../shared/widgets/loading_widgets.dart';
0015: import '../../../features/weather/providers/weather_provider.dart';
0016: import '../../../features/weather/providers/commune_provider.dart';
0017: import '../../../core/providers/activity_tracker_v3_provider.dart' as v3;
0018: import '../../widgets/organic_dashboard.dart';
0019: 
0020: /// HomeScreen - Ã©cran d'accueil principal
0021: class HomeScreen extends ConsumerWidget {
0022:   const HomeScreen({super.key});
0023: 
0024:   @override
0025:   Widget build(BuildContext context, WidgetRef ref) {
0026:     final gardenState = ref.watch(gardenProvider);
0027:     final theme = Theme.of(context);
0028:     final selectedCommune = ref.watch(selectedCommuneProvider);
0029:     final fallbackCommune = gardenState.gardens.isNotEmpty ? gardenState.gardens.first.location : null;
0030: 
0031:     final weatherAsync = ref.watch(weatherByCommuneProvider(selectedCommune ?? fallbackCommune));
0032: 
0033:     return Scaffold(
0034:       appBar: CustomAppBar(
0035:         title: 'PermaCalendar 2.0',
0036:         actions: [
0037:           IconButton(
0038:             icon: const Icon(Icons.settings),
0039:             onPressed: () => context.push(AppRoutes.settings),
0040:           ),
0041:         ],
0042:       ),
0043:       body: RefreshIndicator(
0044:         onRefresh: () async {
0045:           await ref.read(gardenProvider.notifier).loadGardens();
0046:         },
0047:         child: SingleChildScrollView(
0048:           padding: const EdgeInsets.all(16),
0049:           child: Column(
0050:             crossAxisAlignment: CrossAxisAlignment.start,
0051:             children: [
0052:               _buildWeatherHome(context, theme, weatherAsync),
0053:               const SizedBox(height: 24),
0054:               _buildQuickActions(context, theme, gardenState, ref),
0055:               const SizedBox(height: 24),
0056:               _buildIntelligenceSection(context, theme),
0057:               const SizedBox(height: 24),
0058:               _buildRecentActivity(context, theme, ref),
0059:             ],
0060:           ),
0061:         ),
0062:       ),
0063:     );
0064:   }
0065: 
0066:   // ----------------------------
0067:   // Weather section
0068:   // ----------------------------
0069:   Widget _buildWeatherHome(
0070:     BuildContext context,
0071:     ThemeData theme,
0072:     AsyncValue<WeatherViewData> weatherAsync,
0073:   ) {
0074:     return CustomCard(
0075:       child: Padding(
0076:         padding: const EdgeInsets.all(16),
0077:         child: weatherAsync.when(
0078:           loading: () => const LoadingWidget(),
0079:           error: (e, st) => ErrorStateWidget(
0080:             title: 'MÃ©tÃ©o indisponible',
0081:             subtitle: e.toString(),
0082:             retryText: 'RÃ©essayer',
0083:             onRetry: () {},
0084:           ),
0085:           data: (data) {
0086:             // On s'attend Ã  ce que splitByToday() retourne un record (past, forecast).
0087:             // On utilise la destructuration de record disponible en Dart 3.
0088:             List<DailyWeatherPoint> past = <DailyWeatherPoint>[];
0089:             List<DailyWeatherPoint> forecast = <DailyWeatherPoint>[];
0090: 
0091:             try {
0092:               // Si splitByToday renvoie un record (List, List), utiliser la destructuration.
0093:               final (p, f) = data.result.splitByToday();
0094:               if (p is List<DailyWeatherPoint>) {
0095:                 past = List<DailyWeatherPoint>.from(p);
0096:               }
0097:               if (f is List<DailyWeatherPoint>) {
0098:                 forecast = List<DailyWeatherPoint>.from(f);
0099:               }
0100:             } catch (_) {
0101:               // Fallback silencieux : si la structure diffÃ¨re, on laisse les listes vides.
0102:             }
0103: 
0104:             final todayPrecip = forecast.isNotEmpty ? forecast.first.precipMm : 0.0;
0105: 
0106:             return ExpansionTile(
0107:               tilePadding: EdgeInsets.zero,
0108:               initiallyExpanded: false,
0109:               title: Row(
0110:                 mainAxisAlignment: MainAxisAlignment.spaceBetween,
0111:                 children: [
0112:                   Column(
0113:                     crossAxisAlignment: CrossAxisAlignment.start,
0114:                     children: [
0115:                       Text(
0116:                         'MÃ©tÃ©o â€” ${data.locationLabel}',
0117:                         style: theme.textTheme.titleLarge?.copyWith(
0118:                           fontWeight: FontWeight.bold,
0119:                         ),
0120:                       ),
0121:                       const SizedBox(height: 4),
0122:                       Text(
0123:                         'Pluie aujourd\'hui: ${todayPrecip.toStringAsFixed(1)} mm',
0124:                         style: theme.textTheme.bodyMedium?.copyWith(
0125:                           color: theme.colorScheme.outline,
0126:                         ),
0127:                       ),
0128:                     ],
0129:                   ),
0130:                   const Icon(Icons.wb_sunny, color: Colors.orange),
0131:                 ],
0132:               ),
0133:               children: [
0134:                 const SizedBox(height: 12),
0135:                 _buildPrecipChips(theme, 'Historique (7 jours)', past.take(7).toList()),
0136:                 const SizedBox(height: 12),
0137:                 _buildPrecipChips(theme, 'PrÃ©visions (7 jours)', forecast.take(7).toList()),
0138:                 const SizedBox(height: 12),
0139:                 _buildPrecipDetails(theme, 'Historique complet', past),
0140:                 const SizedBox(height: 12),
0141:                 _buildPrecipDetails(theme, 'PrÃ©visions dÃ©taillÃ©es', forecast),
0142:                 const SizedBox(height: 16),
0143:                 Align(
0144:                   alignment: Alignment.centerRight,
0145:                   child: TextButton.icon(
0146:                     onPressed: () => context.push(AppRoutes.settings),
0147:                     icon: const Icon(Icons.location_city),
0148:                     label: const Text('Choisir ma commune'),
0149:                   ),
0150:                 ),
0151:               ],
0152:             );
0153:           },
0154:         ),
0155:       ),
0156:     );
0157:   }
0158: 
0159:   Widget _buildPrecipChips(ThemeData theme, String label, List<DailyWeatherPoint> points) {
0160:     return Column(
0161:       crossAxisAlignment: CrossAxisAlignment.start,
0162:       children: [
0163:         Text(label, style: theme.textTheme.titleMedium?.copyWith(fontWeight: FontWeight.w600)),
0164:         const SizedBox(height: 8),
0165:         Wrap(
0166:           spacing: 8,
0167:           runSpacing: 8,
0168:           children: points.cast<DailyWeatherPoint>().map<Widget>((p) {
0169:             final d = '${p.date.day.toString().padLeft(2, '0')}/${p.date.month.toString().padLeft(2, '0')}';
0170:             return Chip(
0171:               label: Text('$d â€¢ ${p.precipMm.toStringAsFixed(1)} mm'),
0172:               avatar: const Icon(Icons.grain, size: 16),
0173:             );
0174:           }).toList(),
0175:         ),
0176:       ],
0177:     );
0178:   }
0179: 
0180:   Widget _buildPrecipDetails(ThemeData theme, String label, List<DailyWeatherPoint> points) {
0181:     return Column(
0182:       crossAxisAlignment: CrossAxisAlignment.start,
0183:       children: [
0184:         Text(label, style: theme.textTheme.titleMedium?.copyWith(fontWeight: FontWeight.w600)),
0185:         const SizedBox(height: 8),
0186:         Column(
0187:           children: points.cast<DailyWeatherPoint>().map<Widget>((p) {
0188:             final d = '${p.date.day.toString().padLeft(2, '0')}/${p.date.month.toString().padLeft(2, '0')}/${p.date.year}';
0189:             final tRange = (p.tMinC != null && p.tMaxC != null) ? ' â€¢ ${p.tMinC!.toStringAsFixed(0)}â€“${p.tMaxC!.toStringAsFixed(0)}Â°C' : '';
0190:             return Row(
0191:               children: [
0192:                 Expanded(child: Text(d, style: theme.textTheme.bodyMedium)),
0193:                 Text('${p.precipMm.toStringAsFixed(1)} mm$tRange', style: theme.textTheme.bodyMedium?.copyWith(fontWeight: FontWeight.w600)),
0194:               ],
0195:             );
0196:           }).toList(),
0197:         ),
0198:       ],
0199:     );
0200:   }

--- FILE: lib/shared/widgets/organic_dashboard.dart ---
0001: // lib/shared/widgets/organic_dashboard.dart
0002: import 'package:flutter/foundation.dart';
0003: import 'package:flutter/material.dart';
0004: import 'package:flutter/services.dart';
0005: import 'package:go_router/go_router.dart';
0006: 
0007: import '../../app_router.dart';
0008: 
0009: /// OrganicDashboardWidget
0010: ///
0011: /// - Affiche une grande image organique (background PNG).
0012: /// - Superpose des hotspots (définis en fractions) qui déclenchent des routes.
0013: /// - En mode debug, affiche un outline semi-transparent + label pour caler les zones.
0014: /// - Si l'asset manque, affiche un fallback visuel.
0015: /// - En mode debug, affiche un panneau visuel contenant :
0016: ///    * build called
0017: ///    * si AssetManifest contient l'asset
0018: ///    * si rootBundle.load réussit et la taille (bytes) ou l'erreur.
0019: class OrganicDashboardWidget extends StatelessWidget {
0020:   const OrganicDashboardWidget({
0021:     super.key,
0022:     this.assetPath = 'assets/images/backgrounds/dashboard_organic_final.png',
0023:   });
0024: 
0025:   final String assetPath;
0026: 
0027:   static const List<_Hotspot> _hotspots = <_Hotspot>[
0028:     _Hotspot(
0029:       id: 'intelligence',
0030:       centerX: 0.18,
0031:       centerY: 0.22,
0032:       widthFrac: 0.20,
0033:       heightFrac: 0.20,
0034:       route: AppRoutes.intelligence,
0035:       label: 'Intelligence',
0036:     ),
0037:     _Hotspot(
0038:       id: 'calendar',
0039:       centerX: 0.18,
0040:       centerY: 0.50,
0041:       widthFrac: 0.20,
0042:       heightFrac: 0.20,
0043:       route: AppRoutes.calendar,
0044:       label: 'Calendar',
0045:     ),
0046:     _Hotspot(
0047:       id: 'activities',
0048:       centerX: 0.18,
0049:       centerY: 0.78,
0050:       widthFrac: 0.20,
0051:       heightFrac: 0.20,
0052:       route: AppRoutes.activities,
0053:       label: 'Activities',
0054:     ),
0055:     _Hotspot(
0056:       id: 'gardens',
0057:       centerX: 0.65,
0058:       centerY: 0.28,
0059:       widthFrac: 0.42,
0060:       heightFrac: 0.36,
0061:       route: AppRoutes.gardens,
0062:       label: 'Gardens',
0063:     ),
0064:   ];
0065: 
0066:   // Diagnostic helper that returns asset checks
0067:   static Future<_AssetDiagnostic> _diagnoseAsset(String assetPath) async {
0068:     final diag = _AssetDiagnostic();
0069:     try {
0070:       final manifest = await rootBundle.loadString('AssetManifest.json');
0071:       diag.manifestLoaded = true;
0072:       diag.declared = manifest.contains('"$assetPath"') || manifest.contains(assetPath);
0073:     } catch (e) {
0074:       diag.manifestLoaded = false;
0075:       diag.manifestError = e.toString();
0076:       diag.declared = false;
0077:     }
0078: 
0079:     try {
0080:       final bd = await rootBundle.load(assetPath);
0081:       diag.loadOk = true;
0082:       diag.sizeBytes = bd.lengthInBytes;
0083:     } catch (e) {
0084:       diag.loadOk = false;
0085:       diag.loadError = e.toString();
0086:     }
0087: 
0088:     return diag;
0089:   }
0090: 
0091:   @override
0092:   Widget build(BuildContext context) {
0093:     // Immediate visual trace (will also be shown in the overlay).
0094:     if (kDebugMode) {
0095:       // synchronous debug print to keep older behaviour too
0096:       debugPrint('OrganicDashboard: build called -> $assetPath');
0097:     }
0098: 
0099:     return LayoutBuilder(builder: (context, constraints) {
0100:       final double width =
0101:           constraints.maxWidth.isFinite ? constraints.maxWidth : MediaQuery.of(context).size.width;
0102:       final double height = (width * (9.0 / 5.0)).clamp(300.0, 1400.0);
0103: 
0104:       return SizedBox(
0105:         width: double.infinity,
0106:         height: height,
0107:         child: Stack(
0108:           children: [
0109:             // Background image (cover). errorBuilder gives a visible fallback if missing.
0110:             Positioned.fill(
0111:               child: Image.asset(
0112:                 assetPath,
0113:                 fit: BoxFit.cover,
0114:                 alignment: Alignment.center,
0115:                 isAntiAlias: true,
0116:                 errorBuilder: (context, error, stack) {
0117:                   if (kDebugMode) {
0118:                     debugPrint('OrganicDashboard: asset not found -> $assetPath : $error');
0119:                   }
0120:                   return Container(
0121:                     color: Theme.of(context).colorScheme.surfaceVariant,
0122:                     child: Center(
0123:                       child: Column(
0124:                         mainAxisSize: MainAxisSize.min,
0125:                         children: [
0126:                           Icon(Icons.image_not_supported, size: 48, color: Colors.grey.shade300),
0127:                           const SizedBox(height: 8),
0128:                           Text('Visuel absent', style: Theme.of(context).textTheme.bodyMedium),
0129:                           if (kDebugMode) ...[
0130:                             const SizedBox(height: 8),
0131:                             Text(assetPath, style: Theme.of(context).textTheme.labelSmall),
0132:                           ],
0133:                         ],
0134:                       ),
0135:                     ),
0136:                   );
0137:                 },
0138:               ),
0139:             ),
0140: 
0141:             // Hotspot overlays
0142:             ..._hotspots.map((hs) {
0143:               final double left = (hs.centerX - hs.widthFrac / 2) * width;
0144:               final double top = (hs.centerY - hs.heightFrac / 2) * height;
0145:               final double w = hs.widthFrac * width;
0146:               final double h = hs.heightFrac * height;
0147: 
0148:               return Positioned(
0149:                 left: left,
0150:                 top: top,
0151:                 width: w,
0152:                 height: h,
0153:                 child: _HotspotButton(
0154:                   onTap: () {
0155:                     if (kDebugMode) {
0156:                       debugPrint('OrganicDashboard: tapped hotspot (${hs.id}) -> ${hs.route}');
0157:                     }
0158:                     context.push(hs.route);
0159:                   },
0160:                   showDebugOutline: kDebugMode,
0161:                   semanticLabel: hs.label,
0162:                 ),
0163:               );
0164:             }).toList(),
0165: 
0166:             // Debug overlay (visible only in debug mode)
0167:             if (kDebugMode)
0168:               Positioned(
0169:                 top: 8,
0170:                 right: 8,
0171:                 child: FutureBuilder<_AssetDiagnostic>(
0172:                   future: _diagnoseAsset(assetPath),
0173:                   builder: (context, snap) {
0174:                     String title = 'Dashboard asset';
0175:                     Color bg = Colors.black54;
0176:                     Widget body;
0177: 
0178:                     if (snap.connectionState != ConnectionState.done) {
0179:                       body = Row(
0180:                         children: const [
0181:                           SizedBox(width: 8),
0182:                           SizedBox(width: 12, height: 12, child: CircularProgressIndicator(strokeWidth: 2)),
0183:                           SizedBox(width: 8),
0184:                           Text('Checking...', style: TextStyle(color: Colors.white, fontSize: 12)),
0185:                         ],
0186:                       );
0187:                     } else if (snap.hasError) {
0188:                       body = Text('Diag failed: ${snap.error}', style: const TextStyle(color: Colors.redAccent, fontSize: 12));
0189:                     } else {
0190:                       final d = snap.data!;
0191:                       final declared = d.declared ? 'YES' : 'NO';
0192:                       final declaredColor = d.declared ? Colors.greenAccent : Colors.orangeAccent;
0193:                       final loadOk = d.loadOk ? 'OK (${d.sizeBytes ?? 0} bytes)' : 'FAILED';
0194:                       final loadColor = d.loadOk ? Colors.greenAccent : Colors.redAccent;
0195: 
0196:                       body = Column(
0197:                         crossAxisAlignment: CrossAxisAlignment.start,
0198:                         children: [
0199:                           Row(
0200:                             children: [

--- FILE: lib/shared/widgets/custom_card.dart ---
0001: import 'package:flutter/material.dart';
0002: 
0003: /// Carte personnalisée de base
0004: class CustomCard extends StatelessWidget {
0005:   final Widget child;
0006:   final EdgeInsetsGeometry? padding;
0007:   final EdgeInsetsGeometry? margin;
0008:   final Color? color;
0009:   final double? elevation;
0010:   final BorderRadius? borderRadius;
0011:   final VoidCallback? onTap;
0012:   final bool isSelected;
0013:   final Border? border;
0014: 
0015:   const CustomCard({
0016:     super.key,
0017:     required this.child,
0018:     this.padding,
0019:     this.margin,
0020:     this.color,
0021:     this.elevation,
0022:     this.borderRadius,
0023:     this.onTap,
0024:     this.isSelected = false,
0025:     this.border,
0026:   });
0027: 
0028:   @override
0029:   Widget build(BuildContext context) {
0030:     final theme = Theme.of(context);
0031: 
0032:     Widget card = Card(
0033:       color: color ?? theme.cardColor,
0034:       elevation: elevation ?? 2,
0035:       shape: RoundedRectangleBorder(
0036:         borderRadius: borderRadius ?? BorderRadius.circular(12),
0037:         side: isSelected
0038:             ? const BorderSide(
0039:                 color: Colors.blue,
0040:                 width: 2,
0041:               )
0042:             : BorderSide.none,
0043:       ),
0044:       margin: margin ?? const EdgeInsets.all(8),
0045:       child: InkWell(
0046:         onTap: onTap,
0047:         borderRadius: borderRadius ?? BorderRadius.circular(12),
0048:         child: Padding(
0049:           padding: padding ?? const EdgeInsets.all(16),
0050:           child: child,
0051:         ),
0052:       ),
0053:     );
0054: 
0055:     return card;
0056:   }
0057: }
0058: 
0059: /// Carte avec en-tête et contenu
0060: class HeaderCard extends StatelessWidget {
0061:   final String title;
0062:   final String? subtitle;
0063:   final Widget? leading;
0064:   final List<Widget>? actions;
0065:   final Widget? content;
0066:   final EdgeInsetsGeometry? padding;
0067:   final EdgeInsetsGeometry? margin;
0068:   final VoidCallback? onTap;
0069:   final bool isExpanded;
0070: 
0071:   const HeaderCard({
0072:     super.key,
0073:     required this.title,
0074:     this.subtitle,
0075:     this.leading,
0076:     this.actions,
0077:     this.content,
0078:     this.padding,
0079:     this.margin,
0080:     this.onTap,
0081:     this.isExpanded = true,
0082:   });
0083: 
0084:   @override
0085:   Widget build(BuildContext context) {
0086:     final theme = Theme.of(context);
0087: 
0088:     return CustomCard(
0089:       padding: EdgeInsets.zero,
0090:       margin: margin,
0091:       onTap: onTap,
0092:       child: Column(
0093:         crossAxisAlignment: CrossAxisAlignment.start,
0094:         mainAxisSize: MainAxisSize.min,
0095:         children: [
0096:           // En-tête
0097:           Padding(
0098:             padding: const EdgeInsets.all(16),
0099:             child: Row(
0100:               children: [
0101:                 if (leading != null) ...[
0102:                   leading!,
0103:                   const SizedBox(width: 12),
0104:                 ],
0105:                 Expanded(
0106:                   child: Column(
0107:                     crossAxisAlignment: CrossAxisAlignment.start,
0108:                     children: [
0109:                       Text(
0110:                         title,
0111:                         style: theme.textTheme.titleMedium?.copyWith(
0112:                           fontWeight: FontWeight.w600,
0113:                         ),
0114:                       ),
0115:                       if (subtitle != null) ...[
0116:                         const SizedBox(height: 4),
0117:                         Text(
0118:                           subtitle!,
0119:                           style: theme.textTheme.bodySmall?.copyWith(
0120:                             color: theme.colorScheme.onSurface.withOpacity(0.7),
0121:                           ),
0122:                         ),
0123:                       ],
0124:                     ],
0125:                   ),
0126:                 ),
0127:                 if (actions != null) ...actions!,
0128:               ],
0129:             ),
0130:           ),
0131: 
0132:           // Contenu
0133:           if (content != null) ...[
0134:             const Divider(height: 1),
0135:             Padding(
0136:               padding: padding ?? const EdgeInsets.all(16),
0137:               child: content!,
0138:             ),
0139:           ],
0140:         ],
0141:       ),
0142:     );
0143:   }
0144: }
0145: 
0146: /// Carte d'information avec icône
0147: class InfoCard extends StatelessWidget {
0148:   final IconData icon;
0149:   final String title;
0150:   final String? subtitle;
0151:   final String? value;
0152:   final Color? iconColor;
0153:   final Color? backgroundColor;
0154:   final VoidCallback? onTap;
0155:   final EdgeInsetsGeometry? margin;
0156: 
0157:   const InfoCard({
0158:     super.key,
0159:     required this.icon,
0160:     required this.title,
0161:     this.subtitle,
0162:     this.value,
0163:     this.iconColor,
0164:     this.backgroundColor,
0165:     this.onTap,
0166:     this.margin,
0167:   });
0168: 
0169:   @override
0170:   Widget build(BuildContext context) {
0171:     final theme = Theme.of(context);
0172: 
0173:     return CustomCard(
0174:       color: backgroundColor,
0175:       margin: margin,
0176:       onTap: onTap,
0177:       child: Row(
0178:         children: [
0179:           Container(
0180:             padding: const EdgeInsets.all(12),
0181:             decoration: BoxDecoration(
0182:               color: (iconColor ?? theme.colorScheme.primary).withOpacity(0.1),
0183:               borderRadius: BorderRadius.circular(8),
0184:             ),
0185:             child: Icon(
0186:               icon,
0187:               color: iconColor ?? theme.colorScheme.primary,
0188:               size: 24,
0189:             ),
0190:           ),
0191:           const SizedBox(width: 16),
0192:           Expanded(
0193:             child: Column(
0194:               crossAxisAlignment: CrossAxisAlignment.start,
0195:               children: [
0196:                 Text(
0197:                   title,
0198:                   style: theme.textTheme.titleSmall?.copyWith(
0199:                     fontWeight: FontWeight.w600,
0200:                   ),

