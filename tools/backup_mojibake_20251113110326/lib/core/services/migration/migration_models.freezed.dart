// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'migration_models.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$MigrationConfig {
  int get batchSize => throw _privateConstructorUsedError;
  Duration get pauseBetweenBatches => throw _privateConstructorUsedError;
  double get maxErrorRate => throw _privateConstructorUsedError;
  double get minSuccessRate => throw _privateConstructorUsedError;
  Duration get monitoringPeriod => throw _privateConstructorUsedError;
  bool get autoCleanupLegacy => throw _privateConstructorUsedError;
  bool get enableRollback => throw _privateConstructorUsedError;
  bool get validateAfterEachBatch => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $MigrationConfigCopyWith<MigrationConfig> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MigrationConfigCopyWith<$Res> {
  factory $MigrationConfigCopyWith(
          MigrationConfig value, $Res Function(MigrationConfig) then) =
      _$MigrationConfigCopyWithImpl<$Res, MigrationConfig>;
  @useResult
  $Res call(
      {int batchSize,
      Duration pauseBetweenBatches,
      double maxErrorRate,
      double minSuccessRate,
      Duration monitoringPeriod,
      bool autoCleanupLegacy,
      bool enableRollback,
      bool validateAfterEachBatch});
}

/// @nodoc
class _$MigrationConfigCopyWithImpl<$Res, $Val extends MigrationConfig>
    implements $MigrationConfigCopyWith<$Res> {
  _$MigrationConfigCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? batchSize = null,
    Object? pauseBetweenBatches = null,
    Object? maxErrorRate = null,
    Object? minSuccessRate = null,
    Object? monitoringPeriod = null,
    Object? autoCleanupLegacy = null,
    Object? enableRollback = null,
    Object? validateAfterEachBatch = null,
  }) {
    return _then(_value.copyWith(
      batchSize: null == batchSize
          ? _value.batchSize
          : batchSize // ignore: cast_nullable_to_non_nullable
              as int,
      pauseBetweenBatches: null == pauseBetweenBatches
          ? _value.pauseBetweenBatches
          : pauseBetweenBatches // ignore: cast_nullable_to_non_nullable
              as Duration,
      maxErrorRate: null == maxErrorRate
          ? _value.maxErrorRate
          : maxErrorRate // ignore: cast_nullable_to_non_nullable
              as double,
      minSuccessRate: null == minSuccessRate
          ? _value.minSuccessRate
          : minSuccessRate // ignore: cast_nullable_to_non_nullable
              as double,
      monitoringPeriod: null == monitoringPeriod
          ? _value.monitoringPeriod
          : monitoringPeriod // ignore: cast_nullable_to_non_nullable
              as Duration,
      autoCleanupLegacy: null == autoCleanupLegacy
          ? _value.autoCleanupLegacy
          : autoCleanupLegacy // ignore: cast_nullable_to_non_nullable
              as bool,
      enableRollback: null == enableRollback
          ? _value.enableRollback
          : enableRollback // ignore: cast_nullable_to_non_nullable
              as bool,
      validateAfterEachBatch: null == validateAfterEachBatch
          ? _value.validateAfterEachBatch
          : validateAfterEachBatch // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MigrationConfigImplCopyWith<$Res>
    implements $MigrationConfigCopyWith<$Res> {
  factory _$$MigrationConfigImplCopyWith(_$MigrationConfigImpl value,
          $Res Function(_$MigrationConfigImpl) then) =
      __$$MigrationConfigImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int batchSize,
      Duration pauseBetweenBatches,
      double maxErrorRate,
      double minSuccessRate,
      Duration monitoringPeriod,
      bool autoCleanupLegacy,
      bool enableRollback,
      bool validateAfterEachBatch});
}

/// @nodoc
class __$$MigrationConfigImplCopyWithImpl<$Res>
    extends _$MigrationConfigCopyWithImpl<$Res, _$MigrationConfigImpl>
    implements _$$MigrationConfigImplCopyWith<$Res> {
  __$$MigrationConfigImplCopyWithImpl(
      _$MigrationConfigImpl _value, $Res Function(_$MigrationConfigImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? batchSize = null,
    Object? pauseBetweenBatches = null,
    Object? maxErrorRate = null,
    Object? minSuccessRate = null,
    Object? monitoringPeriod = null,
    Object? autoCleanupLegacy = null,
    Object? enableRollback = null,
    Object? validateAfterEachBatch = null,
  }) {
    return _then(_$MigrationConfigImpl(
      batchSize: null == batchSize
          ? _value.batchSize
          : batchSize // ignore: cast_nullable_to_non_nullable
              as int,
      pauseBetweenBatches: null == pauseBetweenBatches
          ? _value.pauseBetweenBatches
          : pauseBetweenBatches // ignore: cast_nullable_to_non_nullable
              as Duration,
      maxErrorRate: null == maxErrorRate
          ? _value.maxErrorRate
          : maxErrorRate // ignore: cast_nullable_to_non_nullable
              as double,
      minSuccessRate: null == minSuccessRate
          ? _value.minSuccessRate
          : minSuccessRate // ignore: cast_nullable_to_non_nullable
              as double,
      monitoringPeriod: null == monitoringPeriod
          ? _value.monitoringPeriod
          : monitoringPeriod // ignore: cast_nullable_to_non_nullable
              as Duration,
      autoCleanupLegacy: null == autoCleanupLegacy
          ? _value.autoCleanupLegacy
          : autoCleanupLegacy // ignore: cast_nullable_to_non_nullable
              as bool,
      enableRollback: null == enableRollback
          ? _value.enableRollback
          : enableRollback // ignore: cast_nullable_to_non_nullable
              as bool,
      validateAfterEachBatch: null == validateAfterEachBatch
          ? _value.validateAfterEachBatch
          : validateAfterEachBatch // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$MigrationConfigImpl implements _MigrationConfig {
  const _$MigrationConfigImpl(
      {this.batchSize = 10,
      this.pauseBetweenBatches = const Duration(seconds: 2),
      this.maxErrorRate = 0.2,
      this.minSuccessRate = 0.95,
      this.monitoringPeriod = const Duration(hours: 24),
      this.autoCleanupLegacy = true,
      this.enableRollback = true,
      this.validateAfterEachBatch = true});

  @override
  @JsonKey()
  final int batchSize;
  @override
  @JsonKey()
  final Duration pauseBetweenBatches;
  @override
  @JsonKey()
  final double maxErrorRate;
  @override
  @JsonKey()
  final double minSuccessRate;
  @override
  @JsonKey()
  final Duration monitoringPeriod;
  @override
  @JsonKey()
  final bool autoCleanupLegacy;
  @override
  @JsonKey()
  final bool enableRollback;
  @override
  @JsonKey()
  final bool validateAfterEachBatch;

  @override
  String toString() {
    return 'MigrationConfig(batchSize: $batchSize, pauseBetweenBatches: $pauseBetweenBatches, maxErrorRate: $maxErrorRate, minSuccessRate: $minSuccessRate, monitoringPeriod: $monitoringPeriod, autoCleanupLegacy: $autoCleanupLegacy, enableRollback: $enableRollback, validateAfterEachBatch: $validateAfterEachBatch)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MigrationConfigImpl &&
            (identical(other.batchSize, batchSize) ||
                other.batchSize == batchSize) &&
            (identical(other.pauseBetweenBatches, pauseBetweenBatches) ||
                other.pauseBetweenBatches == pauseBetweenBatches) &&
            (identical(other.maxErrorRate, maxErrorRate) ||
                other.maxErrorRate == maxErrorRate) &&
            (identical(other.minSuccessRate, minSuccessRate) ||
                other.minSuccessRate == minSuccessRate) &&
            (identical(other.monitoringPeriod, monitoringPeriod) ||
                other.monitoringPeriod == monitoringPeriod) &&
            (identical(other.autoCleanupLegacy, autoCleanupLegacy) ||
                other.autoCleanupLegacy == autoCleanupLegacy) &&
            (identical(other.enableRollback, enableRollback) ||
                other.enableRollback == enableRollback) &&
            (identical(other.validateAfterEachBatch, validateAfterEachBatch) ||
                other.validateAfterEachBatch == validateAfterEachBatch));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      batchSize,
      pauseBetweenBatches,
      maxErrorRate,
      minSuccessRate,
      monitoringPeriod,
      autoCleanupLegacy,
      enableRollback,
      validateAfterEachBatch);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MigrationConfigImplCopyWith<_$MigrationConfigImpl> get copyWith =>
      __$$MigrationConfigImplCopyWithImpl<_$MigrationConfigImpl>(
          this, _$identity);
}

abstract class _MigrationConfig implements MigrationConfig {
  const factory _MigrationConfig(
      {final int batchSize,
      final Duration pauseBetweenBatches,
      final double maxErrorRate,
      final double minSuccessRate,
      final Duration monitoringPeriod,
      final bool autoCleanupLegacy,
      final bool enableRollback,
      final bool validateAfterEachBatch}) = _$MigrationConfigImpl;

  @override
  int get batchSize;
  @override
  Duration get pauseBetweenBatches;
  @override
  double get maxErrorRate;
  @override
  double get minSuccessRate;
  @override
  Duration get monitoringPeriod;
  @override
  bool get autoCleanupLegacy;
  @override
  bool get enableRollback;
  @override
  bool get validateAfterEachBatch;
  @override
  @JsonKey(ignore: true)
  _$$MigrationConfigImplCopyWith<_$MigrationConfigImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$MigrationResult {
  bool get success => throw _privateConstructorUsedError;
  MigrationPhase get phase => throw _privateConstructorUsedError;
  String get message => throw _privateConstructorUsedError;
  Duration get duration => throw _privateConstructorUsedError;
  Map<String, dynamic> get details => throw _privateConstructorUsedError;
  DateTime get timestamp => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $MigrationResultCopyWith<MigrationResult> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MigrationResultCopyWith<$Res> {
  factory $MigrationResultCopyWith(
          MigrationResult value, $Res Function(MigrationResult) then) =
      _$MigrationResultCopyWithImpl<$Res, MigrationResult>;
  @useResult
  $Res call(
      {bool success,
      MigrationPhase phase,
      String message,
      Duration duration,
      Map<String, dynamic> details,
      DateTime timestamp});
}

/// @nodoc
class _$MigrationResultCopyWithImpl<$Res, $Val extends MigrationResult>
    implements $MigrationResultCopyWith<$Res> {
  _$MigrationResultCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? success = null,
    Object? phase = null,
    Object? message = null,
    Object? duration = null,
    Object? details = null,
    Object? timestamp = null,
  }) {
    return _then(_value.copyWith(
      success: null == success
          ? _value.success
          : success // ignore: cast_nullable_to_non_nullable
              as bool,
      phase: null == phase
          ? _value.phase
          : phase // ignore: cast_nullable_to_non_nullable
              as MigrationPhase,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      duration: null == duration
          ? _value.duration
          : duration // ignore: cast_nullable_to_non_nullable
              as Duration,
      details: null == details
          ? _value.details
          : details // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      timestamp: null == timestamp
          ? _value.timestamp
          : timestamp // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MigrationResultImplCopyWith<$Res>
    implements $MigrationResultCopyWith<$Res> {
  factory _$$MigrationResultImplCopyWith(_$MigrationResultImpl value,
          $Res Function(_$MigrationResultImpl) then) =
      __$$MigrationResultImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool success,
      MigrationPhase phase,
      String message,
      Duration duration,
      Map<String, dynamic> details,
      DateTime timestamp});
}

/// @nodoc
class __$$MigrationResultImplCopyWithImpl<$Res>
    extends _$MigrationResultCopyWithImpl<$Res, _$MigrationResultImpl>
    implements _$$MigrationResultImplCopyWith<$Res> {
  __$$MigrationResultImplCopyWithImpl(
      _$MigrationResultImpl _value, $Res Function(_$MigrationResultImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? success = null,
    Object? phase = null,
    Object? message = null,
    Object? duration = null,
    Object? details = null,
    Object? timestamp = null,
  }) {
    return _then(_$MigrationResultImpl(
      success: null == success
          ? _value.success
          : success // ignore: cast_nullable_to_non_nullable
              as bool,
      phase: null == phase
          ? _value.phase
          : phase // ignore: cast_nullable_to_non_nullable
              as MigrationPhase,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      duration: null == duration
          ? _value.duration
          : duration // ignore: cast_nullable_to_non_nullable
              as Duration,
      details: null == details
          ? _value._details
          : details // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      timestamp: null == timestamp
          ? _value.timestamp
          : timestamp // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc

class _$MigrationResultImpl extends _MigrationResult {
  const _$MigrationResultImpl(
      {required this.success,
      required this.phase,
      required this.message,
      required this.duration,
      required final Map<String, dynamic> details,
      required this.timestamp})
      : _details = details,
        super._();

  @override
  final bool success;
  @override
  final MigrationPhase phase;
  @override
  final String message;
  @override
  final Duration duration;
  final Map<String, dynamic> _details;
  @override
  Map<String, dynamic> get details {
    if (_details is EqualUnmodifiableMapView) return _details;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_details);
  }

  @override
  final DateTime timestamp;

  @override
  String toString() {
    return 'MigrationResult(success: $success, phase: $phase, message: $message, duration: $duration, details: $details, timestamp: $timestamp)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MigrationResultImpl &&
            (identical(other.success, success) || other.success == success) &&
            (identical(other.phase, phase) || other.phase == phase) &&
            (identical(other.message, message) || other.message == message) &&
            (identical(other.duration, duration) ||
                other.duration == duration) &&
            const DeepCollectionEquality().equals(other._details, _details) &&
            (identical(other.timestamp, timestamp) ||
                other.timestamp == timestamp));
  }

  @override
  int get hashCode => Object.hash(runtimeType, success, phase, message,
      duration, const DeepCollectionEquality().hash(_details), timestamp);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MigrationResultImplCopyWith<_$MigrationResultImpl> get copyWith =>
      __$$MigrationResultImplCopyWithImpl<_$MigrationResultImpl>(
          this, _$identity);
}

abstract class _MigrationResult extends MigrationResult {
  const factory _MigrationResult(
      {required final bool success,
      required final MigrationPhase phase,
      required final String message,
      required final Duration duration,
      required final Map<String, dynamic> details,
      required final DateTime timestamp}) = _$MigrationResultImpl;
  const _MigrationResult._() : super._();

  @override
  bool get success;
  @override
  MigrationPhase get phase;
  @override
  String get message;
  @override
  Duration get duration;
  @override
  Map<String, dynamic> get details;
  @override
  DateTime get timestamp;
  @override
  @JsonKey(ignore: true)
  _$$MigrationResultImplCopyWith<_$MigrationResultImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$PhaseResult {
  bool get success => throw _privateConstructorUsedError;
  MigrationPhase get phase => throw _privateConstructorUsedError;
  String get message => throw _privateConstructorUsedError;
  Duration get duration => throw _privateConstructorUsedError;
  Map<String, dynamic>? get details => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $PhaseResultCopyWith<PhaseResult> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PhaseResultCopyWith<$Res> {
  factory $PhaseResultCopyWith(
          PhaseResult value, $Res Function(PhaseResult) then) =
      _$PhaseResultCopyWithImpl<$Res, PhaseResult>;
  @useResult
  $Res call(
      {bool success,
      MigrationPhase phase,
      String message,
      Duration duration,
      Map<String, dynamic>? details});
}

/// @nodoc
class _$PhaseResultCopyWithImpl<$Res, $Val extends PhaseResult>
    implements $PhaseResultCopyWith<$Res> {
  _$PhaseResultCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? success = null,
    Object? phase = null,
    Object? message = null,
    Object? duration = null,
    Object? details = freezed,
  }) {
    return _then(_value.copyWith(
      success: null == success
          ? _value.success
          : success // ignore: cast_nullable_to_non_nullable
              as bool,
      phase: null == phase
          ? _value.phase
          : phase // ignore: cast_nullable_to_non_nullable
              as MigrationPhase,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      duration: null == duration
          ? _value.duration
          : duration // ignore: cast_nullable_to_non_nullable
              as Duration,
      details: freezed == details
          ? _value.details
          : details // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$PhaseResultImplCopyWith<$Res>
    implements $PhaseResultCopyWith<$Res> {
  factory _$$PhaseResultImplCopyWith(
          _$PhaseResultImpl value, $Res Function(_$PhaseResultImpl) then) =
      __$$PhaseResultImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool success,
      MigrationPhase phase,
      String message,
      Duration duration,
      Map<String, dynamic>? details});
}

/// @nodoc
class __$$PhaseResultImplCopyWithImpl<$Res>
    extends _$PhaseResultCopyWithImpl<$Res, _$PhaseResultImpl>
    implements _$$PhaseResultImplCopyWith<$Res> {
  __$$PhaseResultImplCopyWithImpl(
      _$PhaseResultImpl _value, $Res Function(_$PhaseResultImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? success = null,
    Object? phase = null,
    Object? message = null,
    Object? duration = null,
    Object? details = freezed,
  }) {
    return _then(_$PhaseResultImpl(
      success: null == success
          ? _value.success
          : success // ignore: cast_nullable_to_non_nullable
              as bool,
      phase: null == phase
          ? _value.phase
          : phase // ignore: cast_nullable_to_non_nullable
              as MigrationPhase,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      duration: null == duration
          ? _value.duration
          : duration // ignore: cast_nullable_to_non_nullable
              as Duration,
      details: freezed == details
          ? _value._details
          : details // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc

class _$PhaseResultImpl extends _PhaseResult {
  const _$PhaseResultImpl(
      {required this.success,
      required this.phase,
      required this.message,
      required this.duration,
      final Map<String, dynamic>? details})
      : _details = details,
        super._();

  @override
  final bool success;
  @override
  final MigrationPhase phase;
  @override
  final String message;
  @override
  final Duration duration;
  final Map<String, dynamic>? _details;
  @override
  Map<String, dynamic>? get details {
    final value = _details;
    if (value == null) return null;
    if (_details is EqualUnmodifiableMapView) return _details;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'PhaseResult(success: $success, phase: $phase, message: $message, duration: $duration, details: $details)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PhaseResultImpl &&
            (identical(other.success, success) || other.success == success) &&
            (identical(other.phase, phase) || other.phase == phase) &&
            (identical(other.message, message) || other.message == message) &&
            (identical(other.duration, duration) ||
                other.duration == duration) &&
            const DeepCollectionEquality().equals(other._details, _details));
  }

  @override
  int get hashCode => Object.hash(runtimeType, success, phase, message,
      duration, const DeepCollectionEquality().hash(_details));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PhaseResultImplCopyWith<_$PhaseResultImpl> get copyWith =>
      __$$PhaseResultImplCopyWithImpl<_$PhaseResultImpl>(this, _$identity);
}

abstract class _PhaseResult extends PhaseResult {
  const factory _PhaseResult(
      {required final bool success,
      required final MigrationPhase phase,
      required final String message,
      required final Duration duration,
      final Map<String, dynamic>? details}) = _$PhaseResultImpl;
  const _PhaseResult._() : super._();

  @override
  bool get success;
  @override
  MigrationPhase get phase;
  @override
  String get message;
  @override
  Duration get duration;
  @override
  Map<String, dynamic>? get details;
  @override
  @JsonKey(ignore: true)
  _$$PhaseResultImplCopyWith<_$PhaseResultImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$MigrationBatchResult {
  int get totalItems => throw _privateConstructorUsedError;
  List<String> get successfulMigrations => throw _privateConstructorUsedError;
  Map<String, String> get failedMigrations =>
      throw _privateConstructorUsedError;
  Duration get duration => throw _privateConstructorUsedError;
  double get successRate => throw _privateConstructorUsedError;
  String? get error => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $MigrationBatchResultCopyWith<MigrationBatchResult> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MigrationBatchResultCopyWith<$Res> {
  factory $MigrationBatchResultCopyWith(MigrationBatchResult value,
          $Res Function(MigrationBatchResult) then) =
      _$MigrationBatchResultCopyWithImpl<$Res, MigrationBatchResult>;
  @useResult
  $Res call(
      {int totalItems,
      List<String> successfulMigrations,
      Map<String, String> failedMigrations,
      Duration duration,
      double successRate,
      String? error});
}

/// @nodoc
class _$MigrationBatchResultCopyWithImpl<$Res,
        $Val extends MigrationBatchResult>
    implements $MigrationBatchResultCopyWith<$Res> {
  _$MigrationBatchResultCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? totalItems = null,
    Object? successfulMigrations = null,
    Object? failedMigrations = null,
    Object? duration = null,
    Object? successRate = null,
    Object? error = freezed,
  }) {
    return _then(_value.copyWith(
      totalItems: null == totalItems
          ? _value.totalItems
          : totalItems // ignore: cast_nullable_to_non_nullable
              as int,
      successfulMigrations: null == successfulMigrations
          ? _value.successfulMigrations
          : successfulMigrations // ignore: cast_nullable_to_non_nullable
              as List<String>,
      failedMigrations: null == failedMigrations
          ? _value.failedMigrations
          : failedMigrations // ignore: cast_nullable_to_non_nullable
              as Map<String, String>,
      duration: null == duration
          ? _value.duration
          : duration // ignore: cast_nullable_to_non_nullable
              as Duration,
      successRate: null == successRate
          ? _value.successRate
          : successRate // ignore: cast_nullable_to_non_nullable
              as double,
      error: freezed == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MigrationBatchResultImplCopyWith<$Res>
    implements $MigrationBatchResultCopyWith<$Res> {
  factory _$$MigrationBatchResultImplCopyWith(_$MigrationBatchResultImpl value,
          $Res Function(_$MigrationBatchResultImpl) then) =
      __$$MigrationBatchResultImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int totalItems,
      List<String> successfulMigrations,
      Map<String, String> failedMigrations,
      Duration duration,
      double successRate,
      String? error});
}

/// @nodoc
class __$$MigrationBatchResultImplCopyWithImpl<$Res>
    extends _$MigrationBatchResultCopyWithImpl<$Res, _$MigrationBatchResultImpl>
    implements _$$MigrationBatchResultImplCopyWith<$Res> {
  __$$MigrationBatchResultImplCopyWithImpl(_$MigrationBatchResultImpl _value,
      $Res Function(_$MigrationBatchResultImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? totalItems = null,
    Object? successfulMigrations = null,
    Object? failedMigrations = null,
    Object? duration = null,
    Object? successRate = null,
    Object? error = freezed,
  }) {
    return _then(_$MigrationBatchResultImpl(
      totalItems: null == totalItems
          ? _value.totalItems
          : totalItems // ignore: cast_nullable_to_non_nullable
              as int,
      successfulMigrations: null == successfulMigrations
          ? _value._successfulMigrations
          : successfulMigrations // ignore: cast_nullable_to_non_nullable
              as List<String>,
      failedMigrations: null == failedMigrations
          ? _value._failedMigrations
          : failedMigrations // ignore: cast_nullable_to_non_nullable
              as Map<String, String>,
      duration: null == duration
          ? _value.duration
          : duration // ignore: cast_nullable_to_non_nullable
              as Duration,
      successRate: null == successRate
          ? _value.successRate
          : successRate // ignore: cast_nullable_to_non_nullable
              as double,
      error: freezed == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$MigrationBatchResultImpl extends _MigrationBatchResult {
  const _$MigrationBatchResultImpl(
      {required this.totalItems,
      required final List<String> successfulMigrations,
      required final Map<String, String> failedMigrations,
      required this.duration,
      required this.successRate,
      this.error})
      : _successfulMigrations = successfulMigrations,
        _failedMigrations = failedMigrations,
        super._();

  @override
  final int totalItems;
  final List<String> _successfulMigrations;
  @override
  List<String> get successfulMigrations {
    if (_successfulMigrations is EqualUnmodifiableListView)
      return _successfulMigrations;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_successfulMigrations);
  }

  final Map<String, String> _failedMigrations;
  @override
  Map<String, String> get failedMigrations {
    if (_failedMigrations is EqualUnmodifiableMapView) return _failedMigrations;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_failedMigrations);
  }

  @override
  final Duration duration;
  @override
  final double successRate;
  @override
  final String? error;

  @override
  String toString() {
    return 'MigrationBatchResult(totalItems: $totalItems, successfulMigrations: $successfulMigrations, failedMigrations: $failedMigrations, duration: $duration, successRate: $successRate, error: $error)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MigrationBatchResultImpl &&
            (identical(other.totalItems, totalItems) ||
                other.totalItems == totalItems) &&
            const DeepCollectionEquality()
                .equals(other._successfulMigrations, _successfulMigrations) &&
            const DeepCollectionEquality()
                .equals(other._failedMigrations, _failedMigrations) &&
            (identical(other.duration, duration) ||
                other.duration == duration) &&
            (identical(other.successRate, successRate) ||
                other.successRate == successRate) &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      totalItems,
      const DeepCollectionEquality().hash(_successfulMigrations),
      const DeepCollectionEquality().hash(_failedMigrations),
      duration,
      successRate,
      error);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MigrationBatchResultImplCopyWith<_$MigrationBatchResultImpl>
      get copyWith =>
          __$$MigrationBatchResultImplCopyWithImpl<_$MigrationBatchResultImpl>(
              this, _$identity);
}

abstract class _MigrationBatchResult extends MigrationBatchResult {
  const factory _MigrationBatchResult(
      {required final int totalItems,
      required final List<String> successfulMigrations,
      required final Map<String, String> failedMigrations,
      required final Duration duration,
      required final double successRate,
      final String? error}) = _$MigrationBatchResultImpl;
  const _MigrationBatchResult._() : super._();

  @override
  int get totalItems;
  @override
  List<String> get successfulMigrations;
  @override
  Map<String, String> get failedMigrations;
  @override
  Duration get duration;
  @override
  double get successRate;
  @override
  String? get error;
  @override
  @JsonKey(ignore: true)
  _$$MigrationBatchResultImplCopyWith<_$MigrationBatchResultImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$MigrationProgress {
  MigrationPhase get phase => throw _privateConstructorUsedError;
  int get totalItems => throw _privateConstructorUsedError;
  int get processedItems => throw _privateConstructorUsedError;
  int get successfulItems => throw _privateConstructorUsedError;
  int get failedItems => throw _privateConstructorUsedError;
  double get percentComplete => throw _privateConstructorUsedError;
  Duration get estimatedTimeRemaining => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $MigrationProgressCopyWith<MigrationProgress> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MigrationProgressCopyWith<$Res> {
  factory $MigrationProgressCopyWith(
          MigrationProgress value, $Res Function(MigrationProgress) then) =
      _$MigrationProgressCopyWithImpl<$Res, MigrationProgress>;
  @useResult
  $Res call(
      {MigrationPhase phase,
      int totalItems,
      int processedItems,
      int successfulItems,
      int failedItems,
      double percentComplete,
      Duration estimatedTimeRemaining});
}

/// @nodoc
class _$MigrationProgressCopyWithImpl<$Res, $Val extends MigrationProgress>
    implements $MigrationProgressCopyWith<$Res> {
  _$MigrationProgressCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? phase = null,
    Object? totalItems = null,
    Object? processedItems = null,
    Object? successfulItems = null,
    Object? failedItems = null,
    Object? percentComplete = null,
    Object? estimatedTimeRemaining = null,
  }) {
    return _then(_value.copyWith(
      phase: null == phase
          ? _value.phase
          : phase // ignore: cast_nullable_to_non_nullable
              as MigrationPhase,
      totalItems: null == totalItems
          ? _value.totalItems
          : totalItems // ignore: cast_nullable_to_non_nullable
              as int,
      processedItems: null == processedItems
          ? _value.processedItems
          : processedItems // ignore: cast_nullable_to_non_nullable
              as int,
      successfulItems: null == successfulItems
          ? _value.successfulItems
          : successfulItems // ignore: cast_nullable_to_non_nullable
              as int,
      failedItems: null == failedItems
          ? _value.failedItems
          : failedItems // ignore: cast_nullable_to_non_nullable
              as int,
      percentComplete: null == percentComplete
          ? _value.percentComplete
          : percentComplete // ignore: cast_nullable_to_non_nullable
              as double,
      estimatedTimeRemaining: null == estimatedTimeRemaining
          ? _value.estimatedTimeRemaining
          : estimatedTimeRemaining // ignore: cast_nullable_to_non_nullable
              as Duration,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MigrationProgressImplCopyWith<$Res>
    implements $MigrationProgressCopyWith<$Res> {
  factory _$$MigrationProgressImplCopyWith(_$MigrationProgressImpl value,
          $Res Function(_$MigrationProgressImpl) then) =
      __$$MigrationProgressImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {MigrationPhase phase,
      int totalItems,
      int processedItems,
      int successfulItems,
      int failedItems,
      double percentComplete,
      Duration estimatedTimeRemaining});
}

/// @nodoc
class __$$MigrationProgressImplCopyWithImpl<$Res>
    extends _$MigrationProgressCopyWithImpl<$Res, _$MigrationProgressImpl>
    implements _$$MigrationProgressImplCopyWith<$Res> {
  __$$MigrationProgressImplCopyWithImpl(_$MigrationProgressImpl _value,
      $Res Function(_$MigrationProgressImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? phase = null,
    Object? totalItems = null,
    Object? processedItems = null,
    Object? successfulItems = null,
    Object? failedItems = null,
    Object? percentComplete = null,
    Object? estimatedTimeRemaining = null,
  }) {
    return _then(_$MigrationProgressImpl(
      phase: null == phase
          ? _value.phase
          : phase // ignore: cast_nullable_to_non_nullable
              as MigrationPhase,
      totalItems: null == totalItems
          ? _value.totalItems
          : totalItems // ignore: cast_nullable_to_non_nullable
              as int,
      processedItems: null == processedItems
          ? _value.processedItems
          : processedItems // ignore: cast_nullable_to_non_nullable
              as int,
      successfulItems: null == successfulItems
          ? _value.successfulItems
          : successfulItems // ignore: cast_nullable_to_non_nullable
              as int,
      failedItems: null == failedItems
          ? _value.failedItems
          : failedItems // ignore: cast_nullable_to_non_nullable
              as int,
      percentComplete: null == percentComplete
          ? _value.percentComplete
          : percentComplete // ignore: cast_nullable_to_non_nullable
              as double,
      estimatedTimeRemaining: null == estimatedTimeRemaining
          ? _value.estimatedTimeRemaining
          : estimatedTimeRemaining // ignore: cast_nullable_to_non_nullable
              as Duration,
    ));
  }
}

/// @nodoc

class _$MigrationProgressImpl extends _MigrationProgress {
  const _$MigrationProgressImpl(
      {required this.phase,
      required this.totalItems,
      required this.processedItems,
      required this.successfulItems,
      required this.failedItems,
      required this.percentComplete,
      required this.estimatedTimeRemaining})
      : super._();

  @override
  final MigrationPhase phase;
  @override
  final int totalItems;
  @override
  final int processedItems;
  @override
  final int successfulItems;
  @override
  final int failedItems;
  @override
  final double percentComplete;
  @override
  final Duration estimatedTimeRemaining;

  @override
  String toString() {
    return 'MigrationProgress(phase: $phase, totalItems: $totalItems, processedItems: $processedItems, successfulItems: $successfulItems, failedItems: $failedItems, percentComplete: $percentComplete, estimatedTimeRemaining: $estimatedTimeRemaining)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MigrationProgressImpl &&
            (identical(other.phase, phase) || other.phase == phase) &&
            (identical(other.totalItems, totalItems) ||
                other.totalItems == totalItems) &&
            (identical(other.processedItems, processedItems) ||
                other.processedItems == processedItems) &&
            (identical(other.successfulItems, successfulItems) ||
                other.successfulItems == successfulItems) &&
            (identical(other.failedItems, failedItems) ||
                other.failedItems == failedItems) &&
            (identical(other.percentComplete, percentComplete) ||
                other.percentComplete == percentComplete) &&
            (identical(other.estimatedTimeRemaining, estimatedTimeRemaining) ||
                other.estimatedTimeRemaining == estimatedTimeRemaining));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      phase,
      totalItems,
      processedItems,
      successfulItems,
      failedItems,
      percentComplete,
      estimatedTimeRemaining);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MigrationProgressImplCopyWith<_$MigrationProgressImpl> get copyWith =>
      __$$MigrationProgressImplCopyWithImpl<_$MigrationProgressImpl>(
          this, _$identity);
}

abstract class _MigrationProgress extends MigrationProgress {
  const factory _MigrationProgress(
          {required final MigrationPhase phase,
          required final int totalItems,
          required final int processedItems,
          required final int successfulItems,
          required final int failedItems,
          required final double percentComplete,
          required final Duration estimatedTimeRemaining}) =
      _$MigrationProgressImpl;
  const _MigrationProgress._() : super._();

  @override
  MigrationPhase get phase;
  @override
  int get totalItems;
  @override
  int get processedItems;
  @override
  int get successfulItems;
  @override
  int get failedItems;
  @override
  double get percentComplete;
  @override
  Duration get estimatedTimeRemaining;
  @override
  @JsonKey(ignore: true)
  _$$MigrationProgressImplCopyWith<_$MigrationProgressImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$MigrationHealthReport {
  bool get isHealthy => throw _privateConstructorUsedError;
  DateTime get timestamp => throw _privateConstructorUsedError;
  SystemHealth get legacySystemHealth => throw _privateConstructorUsedError;
  SystemHealth get modernSystemHealth => throw _privateConstructorUsedError;
  double get dataCoherence => throw _privateConstructorUsedError;
  double get errorRate => throw _privateConstructorUsedError;
  List<String> get issues => throw _privateConstructorUsedError;
  Map<String, dynamic>? get metrics => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $MigrationHealthReportCopyWith<MigrationHealthReport> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MigrationHealthReportCopyWith<$Res> {
  factory $MigrationHealthReportCopyWith(MigrationHealthReport value,
          $Res Function(MigrationHealthReport) then) =
      _$MigrationHealthReportCopyWithImpl<$Res, MigrationHealthReport>;
  @useResult
  $Res call(
      {bool isHealthy,
      DateTime timestamp,
      SystemHealth legacySystemHealth,
      SystemHealth modernSystemHealth,
      double dataCoherence,
      double errorRate,
      List<String> issues,
      Map<String, dynamic>? metrics});
}

/// @nodoc
class _$MigrationHealthReportCopyWithImpl<$Res,
        $Val extends MigrationHealthReport>
    implements $MigrationHealthReportCopyWith<$Res> {
  _$MigrationHealthReportCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isHealthy = null,
    Object? timestamp = null,
    Object? legacySystemHealth = null,
    Object? modernSystemHealth = null,
    Object? dataCoherence = null,
    Object? errorRate = null,
    Object? issues = null,
    Object? metrics = freezed,
  }) {
    return _then(_value.copyWith(
      isHealthy: null == isHealthy
          ? _value.isHealthy
          : isHealthy // ignore: cast_nullable_to_non_nullable
              as bool,
      timestamp: null == timestamp
          ? _value.timestamp
          : timestamp // ignore: cast_nullable_to_non_nullable
              as DateTime,
      legacySystemHealth: null == legacySystemHealth
          ? _value.legacySystemHealth
          : legacySystemHealth // ignore: cast_nullable_to_non_nullable
              as SystemHealth,
      modernSystemHealth: null == modernSystemHealth
          ? _value.modernSystemHealth
          : modernSystemHealth // ignore: cast_nullable_to_non_nullable
              as SystemHealth,
      dataCoherence: null == dataCoherence
          ? _value.dataCoherence
          : dataCoherence // ignore: cast_nullable_to_non_nullable
              as double,
      errorRate: null == errorRate
          ? _value.errorRate
          : errorRate // ignore: cast_nullable_to_non_nullable
              as double,
      issues: null == issues
          ? _value.issues
          : issues // ignore: cast_nullable_to_non_nullable
              as List<String>,
      metrics: freezed == metrics
          ? _value.metrics
          : metrics // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MigrationHealthReportImplCopyWith<$Res>
    implements $MigrationHealthReportCopyWith<$Res> {
  factory _$$MigrationHealthReportImplCopyWith(
          _$MigrationHealthReportImpl value,
          $Res Function(_$MigrationHealthReportImpl) then) =
      __$$MigrationHealthReportImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool isHealthy,
      DateTime timestamp,
      SystemHealth legacySystemHealth,
      SystemHealth modernSystemHealth,
      double dataCoherence,
      double errorRate,
      List<String> issues,
      Map<String, dynamic>? metrics});
}

/// @nodoc
class __$$MigrationHealthReportImplCopyWithImpl<$Res>
    extends _$MigrationHealthReportCopyWithImpl<$Res,
        _$MigrationHealthReportImpl>
    implements _$$MigrationHealthReportImplCopyWith<$Res> {
  __$$MigrationHealthReportImplCopyWithImpl(_$MigrationHealthReportImpl _value,
      $Res Function(_$MigrationHealthReportImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isHealthy = null,
    Object? timestamp = null,
    Object? legacySystemHealth = null,
    Object? modernSystemHealth = null,
    Object? dataCoherence = null,
    Object? errorRate = null,
    Object? issues = null,
    Object? metrics = freezed,
  }) {
    return _then(_$MigrationHealthReportImpl(
      isHealthy: null == isHealthy
          ? _value.isHealthy
          : isHealthy // ignore: cast_nullable_to_non_nullable
              as bool,
      timestamp: null == timestamp
          ? _value.timestamp
          : timestamp // ignore: cast_nullable_to_non_nullable
              as DateTime,
      legacySystemHealth: null == legacySystemHealth
          ? _value.legacySystemHealth
          : legacySystemHealth // ignore: cast_nullable_to_non_nullable
              as SystemHealth,
      modernSystemHealth: null == modernSystemHealth
          ? _value.modernSystemHealth
          : modernSystemHealth // ignore: cast_nullable_to_non_nullable
              as SystemHealth,
      dataCoherence: null == dataCoherence
          ? _value.dataCoherence
          : dataCoherence // ignore: cast_nullable_to_non_nullable
              as double,
      errorRate: null == errorRate
          ? _value.errorRate
          : errorRate // ignore: cast_nullable_to_non_nullable
              as double,
      issues: null == issues
          ? _value._issues
          : issues // ignore: cast_nullable_to_non_nullable
              as List<String>,
      metrics: freezed == metrics
          ? _value._metrics
          : metrics // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc

class _$MigrationHealthReportImpl extends _MigrationHealthReport {
  const _$MigrationHealthReportImpl(
      {required this.isHealthy,
      required this.timestamp,
      required this.legacySystemHealth,
      required this.modernSystemHealth,
      required this.dataCoherence,
      required this.errorRate,
      required final List<String> issues,
      final Map<String, dynamic>? metrics})
      : _issues = issues,
        _metrics = metrics,
        super._();

  @override
  final bool isHealthy;
  @override
  final DateTime timestamp;
  @override
  final SystemHealth legacySystemHealth;
  @override
  final SystemHealth modernSystemHealth;
  @override
  final double dataCoherence;
  @override
  final double errorRate;
  final List<String> _issues;
  @override
  List<String> get issues {
    if (_issues is EqualUnmodifiableListView) return _issues;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_issues);
  }

  final Map<String, dynamic>? _metrics;
  @override
  Map<String, dynamic>? get metrics {
    final value = _metrics;
    if (value == null) return null;
    if (_metrics is EqualUnmodifiableMapView) return _metrics;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'MigrationHealthReport(isHealthy: $isHealthy, timestamp: $timestamp, legacySystemHealth: $legacySystemHealth, modernSystemHealth: $modernSystemHealth, dataCoherence: $dataCoherence, errorRate: $errorRate, issues: $issues, metrics: $metrics)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MigrationHealthReportImpl &&
            (identical(other.isHealthy, isHealthy) ||
                other.isHealthy == isHealthy) &&
            (identical(other.timestamp, timestamp) ||
                other.timestamp == timestamp) &&
            (identical(other.legacySystemHealth, legacySystemHealth) ||
                other.legacySystemHealth == legacySystemHealth) &&
            (identical(other.modernSystemHealth, modernSystemHealth) ||
                other.modernSystemHealth == modernSystemHealth) &&
            (identical(other.dataCoherence, dataCoherence) ||
                other.dataCoherence == dataCoherence) &&
            (identical(other.errorRate, errorRate) ||
                other.errorRate == errorRate) &&
            const DeepCollectionEquality().equals(other._issues, _issues) &&
            const DeepCollectionEquality().equals(other._metrics, _metrics));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      isHealthy,
      timestamp,
      legacySystemHealth,
      modernSystemHealth,
      dataCoherence,
      errorRate,
      const DeepCollectionEquality().hash(_issues),
      const DeepCollectionEquality().hash(_metrics));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MigrationHealthReportImplCopyWith<_$MigrationHealthReportImpl>
      get copyWith => __$$MigrationHealthReportImplCopyWithImpl<
          _$MigrationHealthReportImpl>(this, _$identity);
}

abstract class _MigrationHealthReport extends MigrationHealthReport {
  const factory _MigrationHealthReport(
      {required final bool isHealthy,
      required final DateTime timestamp,
      required final SystemHealth legacySystemHealth,
      required final SystemHealth modernSystemHealth,
      required final double dataCoherence,
      required final double errorRate,
      required final List<String> issues,
      final Map<String, dynamic>? metrics}) = _$MigrationHealthReportImpl;
  const _MigrationHealthReport._() : super._();

  @override
  bool get isHealthy;
  @override
  DateTime get timestamp;
  @override
  SystemHealth get legacySystemHealth;
  @override
  SystemHealth get modernSystemHealth;
  @override
  double get dataCoherence;
  @override
  double get errorRate;
  @override
  List<String> get issues;
  @override
  Map<String, dynamic>? get metrics;
  @override
  @JsonKey(ignore: true)
  _$$MigrationHealthReportImplCopyWith<_$MigrationHealthReportImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$CoherenceResult {
  bool get isCoherent => throw _privateConstructorUsedError;
  int get checkedItems => throw _privateConstructorUsedError;
  int get coherentItems => throw _privateConstructorUsedError;
  int get incoherentItems => throw _privateConstructorUsedError;
  List<String> get issues => throw _privateConstructorUsedError;
  double get coherencePercentage => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $CoherenceResultCopyWith<CoherenceResult> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CoherenceResultCopyWith<$Res> {
  factory $CoherenceResultCopyWith(
          CoherenceResult value, $Res Function(CoherenceResult) then) =
      _$CoherenceResultCopyWithImpl<$Res, CoherenceResult>;
  @useResult
  $Res call(
      {bool isCoherent,
      int checkedItems,
      int coherentItems,
      int incoherentItems,
      List<String> issues,
      double coherencePercentage});
}

/// @nodoc
class _$CoherenceResultCopyWithImpl<$Res, $Val extends CoherenceResult>
    implements $CoherenceResultCopyWith<$Res> {
  _$CoherenceResultCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isCoherent = null,
    Object? checkedItems = null,
    Object? coherentItems = null,
    Object? incoherentItems = null,
    Object? issues = null,
    Object? coherencePercentage = null,
  }) {
    return _then(_value.copyWith(
      isCoherent: null == isCoherent
          ? _value.isCoherent
          : isCoherent // ignore: cast_nullable_to_non_nullable
              as bool,
      checkedItems: null == checkedItems
          ? _value.checkedItems
          : checkedItems // ignore: cast_nullable_to_non_nullable
              as int,
      coherentItems: null == coherentItems
          ? _value.coherentItems
          : coherentItems // ignore: cast_nullable_to_non_nullable
              as int,
      incoherentItems: null == incoherentItems
          ? _value.incoherentItems
          : incoherentItems // ignore: cast_nullable_to_non_nullable
              as int,
      issues: null == issues
          ? _value.issues
          : issues // ignore: cast_nullable_to_non_nullable
              as List<String>,
      coherencePercentage: null == coherencePercentage
          ? _value.coherencePercentage
          : coherencePercentage // ignore: cast_nullable_to_non_nullable
              as double,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CoherenceResultImplCopyWith<$Res>
    implements $CoherenceResultCopyWith<$Res> {
  factory _$$CoherenceResultImplCopyWith(_$CoherenceResultImpl value,
          $Res Function(_$CoherenceResultImpl) then) =
      __$$CoherenceResultImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool isCoherent,
      int checkedItems,
      int coherentItems,
      int incoherentItems,
      List<String> issues,
      double coherencePercentage});
}

/// @nodoc
class __$$CoherenceResultImplCopyWithImpl<$Res>
    extends _$CoherenceResultCopyWithImpl<$Res, _$CoherenceResultImpl>
    implements _$$CoherenceResultImplCopyWith<$Res> {
  __$$CoherenceResultImplCopyWithImpl(
      _$CoherenceResultImpl _value, $Res Function(_$CoherenceResultImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isCoherent = null,
    Object? checkedItems = null,
    Object? coherentItems = null,
    Object? incoherentItems = null,
    Object? issues = null,
    Object? coherencePercentage = null,
  }) {
    return _then(_$CoherenceResultImpl(
      isCoherent: null == isCoherent
          ? _value.isCoherent
          : isCoherent // ignore: cast_nullable_to_non_nullable
              as bool,
      checkedItems: null == checkedItems
          ? _value.checkedItems
          : checkedItems // ignore: cast_nullable_to_non_nullable
              as int,
      coherentItems: null == coherentItems
          ? _value.coherentItems
          : coherentItems // ignore: cast_nullable_to_non_nullable
              as int,
      incoherentItems: null == incoherentItems
          ? _value.incoherentItems
          : incoherentItems // ignore: cast_nullable_to_non_nullable
              as int,
      issues: null == issues
          ? _value._issues
          : issues // ignore: cast_nullable_to_non_nullable
              as List<String>,
      coherencePercentage: null == coherencePercentage
          ? _value.coherencePercentage
          : coherencePercentage // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$CoherenceResultImpl extends _CoherenceResult {
  const _$CoherenceResultImpl(
      {required this.isCoherent,
      required this.checkedItems,
      required this.coherentItems,
      required this.incoherentItems,
      required final List<String> issues,
      required this.coherencePercentage})
      : _issues = issues,
        super._();

  @override
  final bool isCoherent;
  @override
  final int checkedItems;
  @override
  final int coherentItems;
  @override
  final int incoherentItems;
  final List<String> _issues;
  @override
  List<String> get issues {
    if (_issues is EqualUnmodifiableListView) return _issues;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_issues);
  }

  @override
  final double coherencePercentage;

  @override
  String toString() {
    return 'CoherenceResult(isCoherent: $isCoherent, checkedItems: $checkedItems, coherentItems: $coherentItems, incoherentItems: $incoherentItems, issues: $issues, coherencePercentage: $coherencePercentage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CoherenceResultImpl &&
            (identical(other.isCoherent, isCoherent) ||
                other.isCoherent == isCoherent) &&
            (identical(other.checkedItems, checkedItems) ||
                other.checkedItems == checkedItems) &&
            (identical(other.coherentItems, coherentItems) ||
                other.coherentItems == coherentItems) &&
            (identical(other.incoherentItems, incoherentItems) ||
                other.incoherentItems == incoherentItems) &&
            const DeepCollectionEquality().equals(other._issues, _issues) &&
            (identical(other.coherencePercentage, coherencePercentage) ||
                other.coherencePercentage == coherencePercentage));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      isCoherent,
      checkedItems,
      coherentItems,
      incoherentItems,
      const DeepCollectionEquality().hash(_issues),
      coherencePercentage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CoherenceResultImplCopyWith<_$CoherenceResultImpl> get copyWith =>
      __$$CoherenceResultImplCopyWithImpl<_$CoherenceResultImpl>(
          this, _$identity);
}

abstract class _CoherenceResult extends CoherenceResult {
  const factory _CoherenceResult(
      {required final bool isCoherent,
      required final int checkedItems,
      required final int coherentItems,
      required final int incoherentItems,
      required final List<String> issues,
      required final double coherencePercentage}) = _$CoherenceResultImpl;
  const _CoherenceResult._() : super._();

  @override
  bool get isCoherent;
  @override
  int get checkedItems;
  @override
  int get coherentItems;
  @override
  int get incoherentItems;
  @override
  List<String> get issues;
  @override
  double get coherencePercentage;
  @override
  @JsonKey(ignore: true)
  _$$CoherenceResultImplCopyWith<_$CoherenceResultImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$MigrationEvent {
  String get eventType => throw _privateConstructorUsedError;
  DateTime get timestamp => throw _privateConstructorUsedError;
  MigrationPhase get phase => throw _privateConstructorUsedError;
  String? get gardenId => throw _privateConstructorUsedError;
  String? get message => throw _privateConstructorUsedError;
  Map<String, dynamic>? get metadata => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $MigrationEventCopyWith<MigrationEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MigrationEventCopyWith<$Res> {
  factory $MigrationEventCopyWith(
          MigrationEvent value, $Res Function(MigrationEvent) then) =
      _$MigrationEventCopyWithImpl<$Res, MigrationEvent>;
  @useResult
  $Res call(
      {String eventType,
      DateTime timestamp,
      MigrationPhase phase,
      String? gardenId,
      String? message,
      Map<String, dynamic>? metadata});
}

/// @nodoc
class _$MigrationEventCopyWithImpl<$Res, $Val extends MigrationEvent>
    implements $MigrationEventCopyWith<$Res> {
  _$MigrationEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? eventType = null,
    Object? timestamp = null,
    Object? phase = null,
    Object? gardenId = freezed,
    Object? message = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_value.copyWith(
      eventType: null == eventType
          ? _value.eventType
          : eventType // ignore: cast_nullable_to_non_nullable
              as String,
      timestamp: null == timestamp
          ? _value.timestamp
          : timestamp // ignore: cast_nullable_to_non_nullable
              as DateTime,
      phase: null == phase
          ? _value.phase
          : phase // ignore: cast_nullable_to_non_nullable
              as MigrationPhase,
      gardenId: freezed == gardenId
          ? _value.gardenId
          : gardenId // ignore: cast_nullable_to_non_nullable
              as String?,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MigrationEventImplCopyWith<$Res>
    implements $MigrationEventCopyWith<$Res> {
  factory _$$MigrationEventImplCopyWith(_$MigrationEventImpl value,
          $Res Function(_$MigrationEventImpl) then) =
      __$$MigrationEventImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String eventType,
      DateTime timestamp,
      MigrationPhase phase,
      String? gardenId,
      String? message,
      Map<String, dynamic>? metadata});
}

/// @nodoc
class __$$MigrationEventImplCopyWithImpl<$Res>
    extends _$MigrationEventCopyWithImpl<$Res, _$MigrationEventImpl>
    implements _$$MigrationEventImplCopyWith<$Res> {
  __$$MigrationEventImplCopyWithImpl(
      _$MigrationEventImpl _value, $Res Function(_$MigrationEventImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? eventType = null,
    Object? timestamp = null,
    Object? phase = null,
    Object? gardenId = freezed,
    Object? message = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_$MigrationEventImpl(
      eventType: null == eventType
          ? _value.eventType
          : eventType // ignore: cast_nullable_to_non_nullable
              as String,
      timestamp: null == timestamp
          ? _value.timestamp
          : timestamp // ignore: cast_nullable_to_non_nullable
              as DateTime,
      phase: null == phase
          ? _value.phase
          : phase // ignore: cast_nullable_to_non_nullable
              as MigrationPhase,
      gardenId: freezed == gardenId
          ? _value.gardenId
          : gardenId // ignore: cast_nullable_to_non_nullable
              as String?,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
      metadata: freezed == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc

class _$MigrationEventImpl extends _MigrationEvent {
  const _$MigrationEventImpl(
      {required this.eventType,
      required this.timestamp,
      required this.phase,
      this.gardenId,
      this.message,
      final Map<String, dynamic>? metadata})
      : _metadata = metadata,
        super._();

  @override
  final String eventType;
  @override
  final DateTime timestamp;
  @override
  final MigrationPhase phase;
  @override
  final String? gardenId;
  @override
  final String? message;
  final Map<String, dynamic>? _metadata;
  @override
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'MigrationEvent(eventType: $eventType, timestamp: $timestamp, phase: $phase, gardenId: $gardenId, message: $message, metadata: $metadata)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MigrationEventImpl &&
            (identical(other.eventType, eventType) ||
                other.eventType == eventType) &&
            (identical(other.timestamp, timestamp) ||
                other.timestamp == timestamp) &&
            (identical(other.phase, phase) || other.phase == phase) &&
            (identical(other.gardenId, gardenId) ||
                other.gardenId == gardenId) &&
            (identical(other.message, message) || other.message == message) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata));
  }

  @override
  int get hashCode => Object.hash(runtimeType, eventType, timestamp, phase,
      gardenId, message, const DeepCollectionEquality().hash(_metadata));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MigrationEventImplCopyWith<_$MigrationEventImpl> get copyWith =>
      __$$MigrationEventImplCopyWithImpl<_$MigrationEventImpl>(
          this, _$identity);
}

abstract class _MigrationEvent extends MigrationEvent {
  const factory _MigrationEvent(
      {required final String eventType,
      required final DateTime timestamp,
      required final MigrationPhase phase,
      final String? gardenId,
      final String? message,
      final Map<String, dynamic>? metadata}) = _$MigrationEventImpl;
  const _MigrationEvent._() : super._();

  @override
  String get eventType;
  @override
  DateTime get timestamp;
  @override
  MigrationPhase get phase;
  @override
  String? get gardenId;
  @override
  String? get message;
  @override
  Map<String, dynamic>? get metadata;
  @override
  @JsonKey(ignore: true)
  _$$MigrationEventImplCopyWith<_$MigrationEventImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
